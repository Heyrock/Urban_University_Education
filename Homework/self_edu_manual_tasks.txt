# Задание 10
# Напишите программу, которая:
#
# получает на вход целое число n – количество точек на плоскости;
# получает n строк с координатами x, y;
# определяет точку, наиболее удаленную от начала координат.

num = 5
my_tpl = tuple(tuple(map(int, input().split())) for _ in range(num))
mx = max(my_tpl, key=lambda x: x[0] ** 2 + x[1] ** 2)
print(mx)

-------------------------------------------

ПРАКТИКА ПО КОРТЕЖАМ

# Задание 1
# Напишите программу, которая:
#
# Создает кортежи из положительных и отрицательных целых чисел на основе
# полученной от пользователя строки.
# Выводит количество положительных и отрицательных чисел в этих кортежах.
# 45 -6 -9 43 23 5 2 -9 -1 6 3
my_input = '45 -6 -9 43 23 5 2 -9 -1 6 3'
pos = tuple(i for i in map(int, my_input.split()) if i > 0)
neg = tuple(i for i in map(int, my_input.split()) if i <= 0)
print(f'Кортеж {pos} состоит из {len(pos)} положительных чисел')
print(f'Кортеж {neg} состоит из {len(neg)} отрицательных чисел')

# Задание 2
# Напишите программу, которая:
#
# Создает кортеж из полученной от пользователя строки,
# состоящей из вещественных чисел, разделенных пробелами.
# Выводит минимальный и максимальный элементы кортежа, а также их сумму.
# 3.45 6.78 8.99 1.45 4.32 19.04 0.55

my_input = '3.45 6.78 8.99 1.45 4.32 19.04 0.55'
my_input = tuple(map(float, my_input.split()))
print(f'Минимальное число: {min(my_input)}')
print(f'Максимальное число: {max(my_input)}')
print(f'Сумма min и max: {(min(my_input) + max(my_input)):.2f}')

# Задание 3
# Имеется кортеж списков, в которых перечислены названия фруктов и калорийность:
# fruit = (['яблоки', 46], ['персики', 49], ['лимоны', 36], ['виноград', 190])
# Калорийность винограда указана ошибочно.
# Напишите программу, которая исправит калорийность на 75, и добавит в третий
# элемент кортежа новое значение ['айва', 42]. Результат должен выглядеть так:
# fruit = (
#     ['яблоки', 46], ['персики', 49], ['лимоны', 36, 'айва', 42], ['виноград', 75]
# )
fruit = (['яблоки', 46], ['персики', 49], ['лимоны', 36], ['виноград', 190])
fruit[3][1] = 75
fruit[2].extend(['айва', 42])
print(fruit)

# Задание 4
# Имеется вложенный кортеж:
# numbers = ((5, 4, 5, 4), (3, 3, 4, 6), (8, 9, 5, 4), (12, 4, 5, 1), (9, 3, 5, 1))
# Напишите программу, которая формирует новый кортеж, состоящий из средних
# арифметических значений элементов numbers.
# Результат выводится в следующем виде:
# 4.5 4.0 6.5 5.5 4.5

numbers = ((5, 4, 5, 4), (3, 3, 4, 6), (8, 9, 5, 4), (12, 4, 5, 1), (9, 3, 5, 1))
avg = tuple(sum(i) / len(i) for i in numbers)
print(*avg)

# Задание 5
# Имеется вложенный кортеж:
# nested_tuple = ((12, 3, 1), (5, 11), (15, 7, 8, 9), (10, 6, 4))
# Напишите программу для преобразования nested_tuple в обычный кортеж,
# упорядоченный по возрастанию:
# (1, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 15)

nested_tuple = ((12, 3, 1), (5, 11), (15, 7, 8, 9), (10, 6, 4))
new_tuple = tuple(i for j in nested_tuple for i in j)
print(sorted(new_tuple))

# ИЛИ:

nested_tuple = ((12, 3, 1), (5, 11), (15, 7, 8, 9), (10, 6, 4))
res = []
flat_list = [res.extend(i) for i in nested_tuple]
print(tuple(sorted(res)))

# Задание 6
# Напишите программу для сортировки вложенного кортежа по третьему элементу.
# Исходный кортеж:
# (('красный', 33, 55), ('зеленый', 17, 44), ('синий', 12, 3), ('черный', 2, 5))
# (('черный', 2, 5), ('синий', 12, 3), ('зеленый', 17, 44), ('красный', 33, 55))

my_tpl = (('красный', 33, 55), ('зеленый', 17, 44), ('синий', 12, 3), ('черный', 2, 5))
new_tpl = tuple(i for i in sorted(my_tpl, key=lambda x: x[2], reverse=False))
print(new_tpl)

# Задание 7
# Напишите программу, которая:
#
#1. принимает на вход строку, состоящую из цифр или символов, разделенных пробелами;
# 35 35 35 35 35
#2. создает из строки кортеж;
#3. проверяет, состоит ли кортеж из одинаковых элементов;
#4. выводит True или False в зависимости от результатов проверки.

# Для проверки соответствия всех элементов одному условию в Python
# используется встроенная функция all():
my_str = '35 35 35 35 35'
my_tuple = tuple(map(int, my_str.split()))
print(all(i == my_tuple[0] for i in my_tuple))

# Задание 8
# Напишите программу, которая на основе исходного кортежа создает новый кортеж,
# из которого исключены все пользователи с номерами телефонов
# с региональным кодом +56.
#
info = (('Евгений Романов', 25, '+56(983)354-67-21'),
    	('Марина Дятлова', 22, '+56(190)251-45-79'),
    	('Кирилл Кудрявцев', 34, '+7(890)456-12-42'),
    	('Сергей Дятлов', 24, '+56(190)156-42-99'),
    	('Юлия Степанова', 21, '+16(398)355-33-09'),
    	('Тимофей Иванов', 34, '+7(918)222-52-77'))

new_info = tuple(i for i in info if not i[2].startswith('+56'))
print(new_info)

# Задание 9
# Имеется кортеж списков:
# numbers = ([4, 5], [4, 5], [1, 6], [7, 3], [3, 3], [2, 4], [9, 5], [1, 1])
# Напишите программу, которая добавит цифру 5 в конец каждого списка.
numbers = ([4, 5], [4, 5], [1, 6], [7, 3], [3, 3], [2, 4], [9, 5], [1, 1])
add = [i.extend([5]) for i in numbers]
print(numbers)

# Задание 10
# Напишите программу, которая:
#
# получает на вход целое число n – количество точек на плоскости;
# получает n строк с координатами x, y;
# определяет точку, наиболее удаленную от начала координат.

num = 5
my_tpl = tuple(tuple(map(int, input().split())) for _ in range(num))
mx = max(my_tpl, key=lambda x: x[0] ** 2 + x[1] ** 2)
print(mx)

---------------------------------------------
# ПРАКТИКА ПО МНОЖЕСТВАМ
# Задание 1
# Напишите программу, которая получает на вход три слова и определяет,
# являются ли они анаграммами друг друга.

a, b, c = 'кластер', 'стрелка', 'сталкер'
# set_a, set_b, set_c = set(input()), set(input()), set(input())
set_a, set_b, set_c = set(a), set(b), set(c)
print('Да' if set_a == set_b == set_c else 'Нет')


# Задание 2
# Напишите программу, которая получает на вход две строки с перечислением интересов
# и хобби двух пользователей, и вычисляет процент совпадения.
# кино книги велосипед хоккей кулинария цветы кошки
# кошки кино путешествия футбол кулинария автомобили дайвинг
# Совпадение интересов: 27.27%

a = 'кино книги велосипед хоккей кулинария цветы кошки'.split()
b = 'кошки кино путешествия футбол кулинария автомобили дайвинг'.split()
set_a = set(a)
set_b = set(b)
my_inter = set_a.intersection(set_b)
print(f'Совпадение интересов: {len(my_inter) / len(set_a.union(set_b)) * 100:.2f}%')

# ИЛИ:

x = input().split()
y = input().split()
result = len(set(x) & set(y)) / float(len(set(x) | set(y))) * 100
print(f'Совпадение интересов: {result:.2f}%')


# Задание 3
# Напишите программу, которая получает на вход строку, и определяет,
# является ли строка панграммой (т.е. содержатся ли в ней все 33
# буквы русского алфавита).
# Широкая электрификация южных губерний даст мощный толчок подъёму сельского хозяйства

str_a = 'Широкая электрификация южных губерний даст мощный толчок подъёму сельского хозяйства'.lower()
set_a = {i for i in str_a if i.isalpha()}
print('Yes' if len(set_a) == 33 else 'no')


# Задание 4
# Напишите программу, которая получает n слов, и вычисляет
# количество уникальных символов во всех словах.
from functools import reduce

words = (
    'программа',
    'код',
    'компьютер',
    'монитор',
    'интерпретатор'
)
print('Количество уникальных символов во всех словах:',
      len(set(''.join([word.lower() for word in words]))))
# n = 5
# print('Количество уникальных символов во всех словах:',
# len(set(''.join([input().lower() for _ in range(n)]))))


# Задание 5
# Напишите программу, которая:
#
# Получает на вход две строки, в которых перечисляются книги,
# прочитанные двумя учениками.
# Выводит количество книг, которые прочитали оба ученика.
list_1 = 'Мастер и Маргарита, Война и мир, Тихий Дон, Евгений Онегин'.split(', ')
list_2 = 'Джейн Эйр, Террор, Война и мир, Мастер и Маргарита, Нос'.split(', ')
print(len(set(list_1) & set(list_2)))


# Задание 6
# Напишите программу, которая получает от пользователя две строки
# с числами, и выводит в порядке возрастания числа, встречающиеся
# в обеих строках.
def prepare(my_string: str):
    my_set = set(int(i) for i in my_string.split() if i.isdigit())
    return my_set


str_1 = '4 12 6 11 0 8 7 5 1 25'
str_2 = '2 1 4 5 56 6 8 7 14 33'
print(sorted(prepare(str_1) & prepare(str_2)))


# Задание 7
# Напишите программу, которая получает два числа и выводит Есть,
# если числа содержат общие цифры, и Нет в противном случае.
a, b = '5678', '3421'
print('Есть' if set(a) & set(b) else 'Нет')


# Задание 8
# Напишите программу, которая получает строку с именами файлов,
# и выводит уникальные имена .jpg файлов, отсортированные в алфавитном порядке.
files = (
    'book_cover.jpg cover.png Book_cover.jpg illustration.jpg ILLUSTRATION.JPG '
    'my_cover.png photo.gif award.jpg Award.jpg award.JPG'
).lower().split()
my_list = sorted(set(i for i in files if i.endswith('.jpg')))
print(*my_list, sep=', ')


# Задание 9
# Два дизайнера поспорили о том, кто из них знает больше оттенков цветов.
# Они перечисляют оттенки, но иногда забывают о том, что уже называли какой-то тон.
# Напишите программу, которая получает на вход n строк с названиями оттенков,
# и определяет, есть ли среди них повторы.
# Если повтор есть, нужно вывести Повтор, если нет – Принято.
num = int(input('Введите число: '))
colors = set(input('Введите цвет: ').lower() for _ in range(num))
print('Accepted' if len(colors) == num else 'Not accepted')



# Задание 10
# Кондитер собирается испечь торт. Напишите программу, которая поможет определить,
# имеются ли в кладовой все необходимые продукты:
#
# - Сначала программа получает список из m продуктов, которые есть в кладовой.
# - Затем получает n ингредиентов, необходимых для рецепта.
# - Выводит Есть, если ингредиент имеется в кладовой, и Отсутствует в противном случае.
# 6
# 5
# мука
# сахар
# Сода
# яйца
# масло сливочное
# масло растительное
# Сахар
# Мука
# Яйца
# сливки
# масло сливочное

m, n = [int(input('Число ')) for _ in 'mn']
pantry = {input('Есть продукт ').lower() for _ in range(m)}
[print('Есть' if input('Нужен продукт ').lower() in pantry else 'Отсутствует') for _ in range(n)]

---------------------------------------------
# ЦИКЛ FOR

# Задание 1
# Напишите программу, которая получает от пользователя число n и выводит n
# строк с результатом умножения чисел от 1 до n на символ *.
n = int(input('Enter number: '))
for i in range(1, n + 1):
    print(f'Умножаю * на {i}: {"*" * (i)}')

# Умножаю * на 1: *
# Умножаю * на 2: **
# Умножаю * на 3: ***
# Умножаю * на 4: ****


lst = map(int, input().split())
pos = 0
negs = 1
min_num = 0
max_num = 0
for i in lst:
    if i > 0:
        pos += 1
    elif i < 0:
        negs *= i
    if i < min_num:
        min_num = i
    elif i > max_num:
        max_num = i
print(f'Количество положительных чисел: {pos}')
print(f'Произведение отрицательных чисел: {negs}')
print(f'Минимальное число: {min_num}')
print(f'Максимальное число: {max_num}')


# Задание 3
# Напишите программу, которая создает вложенный список из n строк,
# полученных от пользователя, и выводит сумму и произведение элементов
# каждого подсписка (без использования sum() и math.prod()).
user_numbers = [
    '4 5 6 7 8',
    '2 1 3 9 8',
    '6 4 3 2 6',
    '9 7 6 3 2',
    '1 4 5 7 2',
    '7 3 2 1 6'
]

num = 6
matrix = []
for i in range(num):
    matrix.append(list(map(int, user_numbers[i].split())))

grand_summ = 0
grand_mult = 1

for i in range(len(matrix)):
    for j in matrix[i]:
        grand_summ += j
        grand_mult *= j
    print(f'Подсписок {i}: сумма чисел = {grand_summ}, произведение = {grand_mult}')

# ИЛИ:

n = int(input())
lst = []
for i in range(n):
    lst.append(list(map(int, input().split())))

summa = 0
prod = 1
for i, j in enumerate(lst):
    for num in j:
        summa += num
        prod *= num
    print(f'Подсписок {i}: сумма чисел = {summa}, произведение = {prod}')


# Задание 4
# Напишите программу, которая получает от пользователя строку текста
# и число n, а затем выводит вложенный список, в котором n последовательных
# элементов принадлежат разным подспискам.
string = 'абвгдеёжз'
num = 3
matrix = []
count = 0

for i in range(num):
    matrix.append([])
    for j in range(count, len(string), num):
        matrix[i].append(string[j])
    count += 1

[print(*matrix[i]) for i in range(len(matrix))]

# ИЛИ:

string = list(input())
num = int(input())
matrix = []

for i in range(num):
    matrix.append(string[i::num])
print(matrix)


# Задание 5
# Напишите программу для транспонирования квадратной матрицы.
# 5
# 1 2 3 4 5
# 1 2 3 4 5
# 1 2 3 4 5
# 1 2 3 4 5
# 1 2 3 4 5
#
# 1 1 1 1 1
# 2 2 2 2 2
# 3 3 3 3 3
# 4 4 4 4 4
# 5 5 5 5 5

num: int = 5
matrix = ['1 2 3 4 5'.split() for _ in range(num)]
[print(*i) for i in matrix]
print()

for i in range(num):
    for j in range(i, num):
        matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
for i in matrix:
    print(*i)


# Задание 6
# Напишите программу, которая выводит на экран снежинку размера n x n.
# Элементы снежинки состоят из символов *, фон – из точек.
# * . * . *
# . * * * .
# * * * * *
# . * * * .
# * . * . *


n = int(input())
snowflake = [['.'] * n for _ in range(n)]

for i in range(n):
    for j in range(n):
        if i == n // 2 or j == n // 2:
            snowflake[i][j] = '*'
        elif i == j or i + j + 1 == n:
            snowflake[i][j] = '*'


[print(*line) for line in snowflake]



# Задание 7
# Напишите программу, которая:
#
# создает квадратную матрицу из полученных на вход строк;
# проверяет, является ли матрица симметричной относительно побочной диагонали;
# выводит Да или Нет в зависимости от результата.
# 4
# 1 2 3 1
# 2 2 2 3
# 3 3 2 2
# 4 3 2 1
num = int(input('Введите число: '))
matrix = [input('введите строку чисел: ') for _ in range(num)]

[print(*i) for i in matrix]

ans = 'Да'
for i in range(num - 1):
    for j in range(num - i - 1):
        if matrix[i][j] != matrix[num - j - 1][num - i - 1]:
            ans = 'Нет'
            break
    if ans == 'Нет':
        break
print(ans)



# Задание 8
# Напишите программу, которая получает от пользователя число
# 1 <= n <= 9, и выводит таблицу умножения для всех чисел от 1 до n.

num = int(input('введите число: '))
for i in range(1, num + 1):
    for j in range(1, 10):
        print(f'{i} * {j} = {i * j}')
    print()



# Задание 9
# Напишите программу, которая получает на вход нечетное положительное
# число n, и выводит треугольник, указывающий вправо.
# *
# **
# ***
# ****
# *****
# ******
# *****
# ****
# ***
# **
# *

# num = int(input('введите число: '))
num = 11
for i in range(1, num // 2 + 2):
    print('*' * i, sep='\n')
for i in range(num // 2, 0, -1):
    print('*' * i)


# Задание 10
# Напишите программу, которая:
#
# получает на вход x и y координаты n точек;
# подсчитывает количество точек в каждой из координатных четвертей.
# Примечание: к четвертям не относят точки, лежащие
# непосредственно на координатных осях X и Y.
# 8
# -4 1
# 3 6
# 7 -9
# -1 -10
# 15 5
# -12 15
# 11 17
# -10 1
#
# Первая четверть: 3
# Вторая четверть: 3
# Третья четверть: 1
# Четвертая четверть: 1

q_1, q_2, q_3, q_4 = 0, 0, 0, 0
for _ in range(int(input('Введите число: '))):
    x, y = [int(i) for i in input('Введите координаты: ').split()]
    if int(x) > 0 and int(y) > 0:
        q_1 += 1
    elif int(x) < 0 and int(y) > 0:
        q_2 += 1
    elif int(x) < 0 and int(y) < 0:
        q_3 += 1
    elif int(x) > 0 and int(y) < 0:
        q_4 += 1

print(
    f'Первая четверть: {q_1}',
    f'Вторая четверть: {q_2}',
    f'Третья четверть: {q_3}',
    f'Четвертая четверть: {q_4}',
    sep='\n'
)
---------------------------------------------
# ПРАКТИКА ЦИКЛА WHILE

# Задание 1
# Напишите программу, которая принимает на вход целые числа и вычисляет
# их сумму, пока пользователь не введет 0.

import random

summa = 0

while True:
    num = random.randint(0, 10)
    if num == 0:
        break
    summa += num

print(summa)


# Задание 2
# Напишите программу, которая получает от пользователя число n > 100,
# и вычисляет (без использования методов строк) произведение цифр,
# из которых n состоит.

num = 335
prod = 1

while num > 1:
    prod *= num % 10
    num //= 10

print(prod)


# Задание 4
# Напишите программу, которая составляет строку из полученных от
# пользователя слов, пока длина строки не достигнет 50 символов.
# Слова, начинающиеся с гласных, в строку не включаются.

vowels = 'аеёиоуыэюя'
string = ''

while len(string) < 50:
    word = input()
    if word[0] not in vowels:
        continue
    string += word + ' '

print(string)


# Задание 5
# Напишите программу для конвертации числа из десятичного системы
# в двоичную без использования функции bin().

num = int(input())
result = ''
while num > 0:
    result = str(num % 2) + result
    num = num // 2
print(result)


# Задание 6
# Напишите программу, которая получает на вход число и без использования
# строковых методов переставляет цифры в обратном порядке.

num = 123456789
new_num = ''

while num:
    x = str(num % 10)
    new_num += x
    num //= 10

print(int(new_num))

# ИЛИ:

num = 123456789
rev = 0
while num!= 0:
    r = num % 10
    rev = rev * 10 + r
    num = num // 10
print(rev)


# Задание 7
# Напишите программу для вычисления факториала числа n без
# использования функции math.factorial().

num = int(input())
fact = 1

while num > 1:
    fact *= num
    num -= 1
print(fact)


# Задание 8
# Напишите программу, которая получает от пользователя число n и
# определяет, является ли оно простым, или у него есть делители,
# кроме 1 и самого себя.

num = int(input())
i = 2
flag = True

while i < num // 2 + 1:
    if num % i == 0:
        flag = False
        print(f'{num} делится на {i}')
    i += 1

print(f'{num} является простым числом' if flag else
      f'Таким образом, {num} не является простым числом')


# Задание 9
# Напишите программу, использующую вложенный цикл while для вывода
# треугольника размером n x n х n, состоящего из символов*.

num = 6
i, j = 0, 0
while i < num:
    while j <= i:
        print('*', end='')
        j += 1
    j = 0
    i += 1
    print()


# Задание 10
# Напишите программу для запоминания английских названий месяцев:
#
# 1. Русские названия месяцев выводятся в случайном порядке с
# помощью метода random.shuffle().
#
# 2. Пользователь получает три попытки для написания правильного названия на английском.
#
# 3. После трех неверных попыток программа переходит к другому слову.

import random

correct, wrong, attempts = 0, 0, 3
months = {'январь': 'January', 'февраль': 'February', 'март': 'March',
          'апрель': 'April', 'май': 'May', 'июнь': 'June',
          'июль': 'July', 'август': 'August', 'сентябрь': 'September',
          'октябрь': 'October', 'ноябрь': 'November', 'декабрь': 'December'}
rand_keys = list(months.keys())
random.shuffle(rand_keys)

for key in rand_keys:
    counter = 0
    while counter < attempts:
        spelling = input(f'Месяц {key} по-английски называется: ')
        if spelling.title() == months[key]:
            correct += 1
            break
        else:
            counter += 1
            wrong += 1
            print(f'Неверно! Осталось попыток: {attempts - counter}')
    else:
        print(f'Попытки исчерпаны!')

print('Конец игры')
print(f'Количество правильных ответов: {correct}')
print(f'Число ошибок: {wrong}')

---------------------------------------------
# ПРАКТИКА ФУНКЦИИ

# Задание 1
# Напишите функцию для вывода треугольника.
# Функция принимает два аргумента – size (размер сторон треугольника)
# и symb (символ, используемый для заполнения треугольника).

def print_triangle(size, symb):
    x = size // 2
    for i in range(x + 1):
        print(symb * i)
    for i in range(x + 1,0,-1):
        print(symb * i)


print_triangle(9, '.')

# ИЛИ:

def draw_triangle(size, symb):
    for i in range(1, size + 1):
        print(symb * max(i, size - i + 1))

size, symb = 9, '.'
draw_triangle(size, symb)


# Задание 2
# Напишите функцию, которая принимает произвольное количество целых чисел,
# и возвращает среднее арифметическое без использования встроенных
# функции sum() и len().
def arith_mean(*args):
    count = 0
    summa = 0
    for i in args:
        count += 1
        summa += i
    return summa / count

print(arith_mean(5, 5, 15, 25, 35))


# Задание 3
# Напишите функцию, которая:
#
# принимает строку, состоящую из букв, цифр и специальных символов;
# формирует три списка – 1) из цифр, 2) из букв, 3) из спецсимволов;
# выводит списки на экран.
def make_lists(string):
    digits = [i for i in string if i.isdigit()]
    letters = [i for i in string if i.isalpha()]
    symbols = [i for i in string if not i.isalnum()]
    return digits, letters, symbols


my_str = '23edwd893rjf934#$%Ye34F^(*))_+W$#Ddq2ddscew3r'
for i in make_lists(my_str):
    print(*i)


# Задание 4
# Напишите функцию, которая начисляет новогодние премии сотрудникам. Эта функция:
#
# имеет два аргумента по умолчанию – salary=120000 и bonus=10 (оклад и премия);
# получает два позиционных аргумента name и last_name – имя и фамилию сотрудника;
# учитывает индивидуальные оклад и премию (см. примеры вызова);
# выводит размер новогодней премии для сотрудника и зарплату с учетом премии.
def ny_bonus(name, last_name, salary=120000, bonus=10):
    calc_bonus = salary * bonus / 100
    text = f'Новогодняя премия сотрудника {name} {last_name}: {calc_bonus:.2f} руб.\n' \
           f'Оклад: {salary:.2f} руб.\n' \
           f'Всего к выдаче: {salary + calc_bonus:.2f} руб.\n'
    print(text)


ny_bonus('Алина', 'Тимофеева', salary=150000, bonus=25)
ny_bonus('Алексей', 'Ковалев', bonus=15)
ny_bonus('Игорь', 'Ефимов')
ny_bonus('Анастасия', 'Яковлева', salary=100000, bonus=20)


# Задание 5
# Напишите программу, которая выводит Есть, если в полученной от пользователя
# строке есть хотя бы одно совершенное число, равное сумме своих делителей,
# и Нет в обратном случае.

def perfect_num(string):
    my_list = list(map(int, string.split()))
    nested_list = []

    for i in range(len(my_list)):
        nested_list.append([])
        for j in range(1, my_list[i] // 2 + 1):
            if my_list[i] % j == 0:
                nested_list[i].append(j)

    print(nested_list)
    for i in range(len(nested_list)):
        if sum(nested_list[i]) == my_list[i]:
            return True
    return False

my_str = '5 7 8 9 34 28'
print('Есть' if perfect_num(my_str) else 'Нет')

# ИЛИ:

def perfect_number(n):
    sum = 0
    for i in range(1, n):
        if n % i == 0:
            sum += i
    return sum == n


my_input = '5 7 8 9 34 28'
numbers = list(map(int, my_input.split()))
flag = 'Нет'
for i in numbers:
    if perfect_number(i):
        flag = 'Есть'
        break
print(flag)


# Задание 6
# Напишите функцию, которая принимает два позиционных аргумента –
# натуральные числа n и k, и возвращает значение биномиального
# коэффициента, не используя math.factorial().

def factorial(num):
    if num <= 1:
        return 1
    return num * factorial(num - 1)

def binomial_coeff(n, k):
    return int(factorial(n) / (factorial(k) * factorial(n - k)))

n, k = 12, 5
print(binomial_coeff(n, k))


# Задание 7
# Напишите функцию, которая принимает число от 1 до 99,
# и возвращает его словесное описание.

def spell_number(num):
    ed = ['один', 'два', 'три', 'четыре', 'пять', 'шесть', 'семь', 'восемь', 'девять', 'десять',
          'одиннадцать', 'двенадцать', 'тринадцать', 'четырнадцать', 'пятнадцать', 'шестнадцать',
          'семнадцать', 'восемнадцать', 'девятнадцать']
    des = ['двадцать', 'тридцать', 'сорок', 'пятьдесят', 'шестьдесят', 'семьдесят', 'восемьдесят', 'девяносто']
    if num < 20:
        return ed[num - 1]
    elif num >= 20:
        if str(num)[1] != '0':
            return des[int(str(num)[0]) - 2] + ' ' + ed[int(str(num)[1]) - 1]
    return des[int(str(num)[0]) - 2]

n = int(input())
print(spell_number(n))


# Задание 8
# Напишите функцию, которая возвращает True, если введенная пользователем дата
# является магической, и False в обратном случае.
# Магической считается дата, в которой произведение дня и месяца равно двум
# последним цифрам года: 02.11.2022.


def convert(string):
    return list(map(int, string.split('.')))


def last_two_digits(integer):
    return int(str(integer)[-2:])


def magic_number(string):
    my_list = convert(string)
    return my_list[0] * my_list[1] == last_two_digits(my_list[2])


my_input = '03.06.2018'
print(magic_number(my_input))

# ИЛИ:

def magic_date(date):
    return int(date[:2]) * int(date[3:5]) == int(date[-2:])

date = input()
print(magic_date(date))


# Задание 9
# Напишите функцию, которая принимает произвольное количество именованных
# аргументов, и формирует из них строку запроса.
# Аргументы в строке запроса должны быть отсортированы в алфавитном порядке.
def make_query(**kwargs):
    string = ''
    my_list = sorted(kwargs)
    for i in range(len(my_list)):
        if i < len(my_list) - 1:
            string += str(my_list[i]) + '=' + str(kwargs[my_list[i]]) + '&'
        else:
            string += str(my_list[i]) + '=' + str(kwargs[my_list[i]])
    return string

# ИЛИ:

def make_query(**kwargs):
    return '&'.join([f'{k}={kwargs[k]}' for k in sorted(kwargs)])


print(make_query(category='books', genre='thriller', author='Stephen_King'))
print(make_query(name='Егор', last_name='Тимохин', age=25, occupation='дизайнер'))


# Задание 10
# Напишите функцию, которая принимает целое число n, и выводит на экран
# спиральную матрицу размера n x n, все элементы которой выровнены по левому краю.

def print_matrix(n):
    matrix = [[0] * n for _ in range(n)]
    vx, vy = [0, 1, 0, -1], [1, 0, -1, 0]
    x, y, z = 0, -1, 1
    for i in range(n + n - 1):
        for j in range((n + n - i) // 2):
            x += vx[i % 4]
            y += vy[i % 4]
            matrix[x][y] = z
            z += 1
    for i in range(len(matrix)):
        for j in range(len(matrix[i])):
            print(str(matrix[i][j]).ljust(3), end='')
        print()

print_matrix(5)

# 1  2  3  4  5
# 16 17 18 19 6
# 15 24 25 20 7
# 14 23 22 21 8
# 13 12 11 10 9

---------------------------------------------
# ПРАКТИКА РЕКУРСИИ

# Задание 1
# Напишите функцию для вычисления факториала числа.
# Решите задачу двумя способами – итеративным и рекурсивным.
#
# Примечание для рекурсивного решения: предположим, нам нужно вычислить 5!
# Факториал 5 равен: 5 х 4 х 3 х 2 х 1.
# Факториал 4: 4 х 3 х 2 х 1, факториал 3: 3 х 2 х 1, факториал 2: 2 х 1,
# и факториал 1 равен 1.
# Очевидно, что 5! = 5 x 4!, 4! = 4 x 3!, 3! = 3 x 2! и так далее до
# граничного случая 1! = 1,
# то есть каждый последующий факториал включает в себя определение предыдущего.

# Решение 1 – итеративное:
def fact_iter(n):
    factorial = 1
    for i in range(1, n + 1):
        factorial *= i
    return factorial


print(fact_iter(int(input())))

# Решение 2 – рекурсивное:
def fact_recursive(n):
    if n == 1:  # граничный случай
        return 1
    else:  # рекурсивный случай
        return n * fact_recursive(n - 1)


print(fact_recursive(int(input())))



# Задание 2
# Напишите программу для возведения числа n в степень m.
# Решите задачу двумя способами – итеративным и рекурсивным.
#
# Примечание для рекурсивного решения: предположим, что нужно
# возвести число 5 в степень 6. Свойства степени позволяют разбить
# процесс на более мелкие операции и представить выражение 5 ** 6
# в виде (5 ** 3) ** 2. Этот подход работает в том случае, если
# степень представляет собой четное число.
# Если степень нечетная, следует воспользоваться другим свойством:
# (n ** m) x n = n ** (m + 1).
# Поскольку может ввести как четное, так и нечетное значение m,
# в функции должны быть два рекурсивных случая.
# В качестве граничного случая используется еще одно свойство степени:
# n ** 1 = n.

def iter(n, m):
    result = 1
    for _ in range(m):
        result *= n
    print(result)


iter(12, 8)


def pow_rec(n, m):
    if m == 1: # граничный случай
        return n
    elif m % 2 == 0: # четный рекурсивный случай
        res = pow_rec(n, m // 2)
        return res * res
    else: # нечетный рекурсивный случай
        res = pow_rec(n, m // 2)
        return res * res * n


print(pow_rec(12, 8))
print(12 ** 8)
print(pow_rec(12, 9))
print(12 ** 9)


# Задание 3
# Напишите программу для нахождения n-го гармонического числа.
# Решите задачу итеративным и рекурсивным способами.
def nth_harmonic_iter(n):
    harmonic = 1.0
    for i in range(2, n + 1):
        harmonic += 1 / i
    return harmonic

print(round(nth_harmonic_iter(7), 5))
# 2.59286

def nth_harmonic_rec(n):
    if n == 1: # граничный случай
        return 1
    else: # рекурсивный случай
        return 1 / n + nth_harmonic_rec(n - 1)

print(round(nth_harmonic_rec(7), 5))
# 2.59286


# Задание 4
# Напишите итеративную и рекурсивную функции для вычисления
# суммы n первых членов геометрической прогрессии:

def geometric_iter(n):
    res = 0
    for i in range(n):
        res += 1 / 2 ** i
    return res

print(geometric_iter(int(input())))
# 9
# 1.99609375

def geometric_rec(n):
    if n < 0: # граничный случай
        return 0
    else: # рекурсивный случай
        return 1 / 2 ** n + geometric_rec(n - 1)

print(geometric_rec(int(input())))
# 9
# 1.998046875

# Примечание: если знаменатель не равен 1, задачу можно решить с
# помощью формулы суммы n первых членов геометрической прогрессии:
b, q, n = 1, 0.5, int(input())
print(b * (1 - q ** n) / (1 - q))
# 9
# 1.99609375


import math

def gcd(a, b):
    while a != 0 and b != 0:
        if a > b:
            a = a % b
        else:
            b = b % a
    return (a + b)

print(gcd(18, 30))

# либо:
print(math.gcd(18, 30))

def gcd_recursive(a, b):
    min_num = min(a, b)
    max_num = max(a, b)
    if min_num == 0:  # граничный случай, когда одно из чисел равно 0
        return max_num
    elif min_num == 1:  # граничный случай, когда одно из чисел равно 1
        return 1
    else:  # рекурсивный случай, когда ни одно из чисел не равно ни 1, ни 0
        return gcd_recursive(min_num, max_num % min_num)


a, b = int(input()), int(input())
print(gcd_recursive(a, b))
# a, b = 18, 30
# 6


# Задание 6
# Напишите итеративную и рекурсивную функции для вычисления последовательности
# n + (n – 2) + (n – 4)... (n – x =< 0), где n – натуральное четное число.

def sum_iter(n):
    summa = 0
    k = 0
    while n - k > 0:
        summa += n - k
        k += 2
    return summa
print(sum_iter(int(input())))
# print(sum_iter(121))
# 120
# 3660

def sum_rec(n):
    if n < 1: # граничный случай
        return 0
    else: # рекурсивный случай
        return n + sum_rec(n - 2)
print(sum_rec(int(input())))
# 120
# 3660


# Задание 7
# Напишите рекурсивную функцию, которая определяет,
# является ли введенная пользователем строка палиндромом.
my_str = 'Лёша на полке клопа нашёл'
my_list = [i.lower() for i in my_str if i.isalpha()]
new_str = ''.join(my_list)
print(new_str == new_str[::-1])
# True


def palindrome_rec(user_str):
    if len(user_str) == 1 or len(user_str) == 1:
        return True
    else:
        head = user_str[0]
        mid = user_str[1: -1]
        tail = user_str[-1]
        return head == tail and palindrome_rec(mid)

str_ = 'Лёша на полке клопа нашёл'
st = [i.lower() for i in str_ if i.isalpha()]
print(palindrome_rec(st))
# True


# Задание 8
# Напишите рекурсивную функцию для поиска имени, состоящего ровно из 9 букв.
# Структура родословной, в которой хранятся данные об именах, имеет древовидную форму:

class Node:
    def __init__(self, data=None, left=None, right=None):
        self.data = data
        self.left = left
        self.right = right


def traverse(root):
    if root is None:
        return

    traverse(root.left)
    if len(root.data) == 9:
        print(f'Имя найдено: {root.data}')
        return

    traverse(root.right)
    if len(root.data) == 9:
        print(f'Имя найдено: {root.data}')
        return


if __name__ == '__main__':
    root = Node('Анна')
    root.left = Node('Егор')
    root.right = Node('Светлана')
    root.left.left = Node('Мария')
    root.right.left = Node('Инга')
    root.right.right = Node('Марина')
    root.right.left.left = Node('Елизавета')
    root.right.left.right = Node('Антон')

    traverse(root)


root = {'name': 'Анна', 'children': [{'name': 'Егор', 'children':
[{'name': 'Мария', 'children': []}]}, {'name': 'Светлана',
'children': [{'name': 'Инга', 'children': [{'name': 'Елизавета',
'children': []}, {'name': 'Антон', 'children': []}]}, {'name': 'Марина', 'children': []}]}]}

def find_name(node):
    print(f"Посещаем узел {node['name']}...")
    print(f"Проверяем, состоит ли имя {node['name']} из 9 букв...")
    if len(node['name']) == 9:
        return node['name'] # граничный случай

    if len(node['children']) > 0:  # рекурсивный случай
        for child in node['children']:
            returnValue = find_name(child)
            if returnValue != 'не найдено':
                return returnValue

    return 'не найдено' # граничный случай - имен из 9 букв нет

print(f"Имя из 9 букв: {find_name(root)}")


# Задание 9
# Имеется многомерный вложенный список:
# Напишите рекурсивную и итеративную функции для преобразования списка в одномерный.
sp = [[[5, 7, 2], [4, 9, 5]], [[2, 5, 4]], [[3, 2, 1], [[5], [9, 5]]],
      [4, 3, 1, 2], [[4, 7, 2], [6, 4]], [[[4, 1, 6], [3, 8]], [4, 5]],
      [9, 1], [3, 1], [[5, 6], [[4, 2, 1], [2, 5], [[6, 8, 2, 3, 4]]]],
      [5, 3, 2], [2, [1], 4], [2, 5, [4, 3, 1], 6, 7, [9, 0, 5, 2, 4]],
      [7, 3, [4]], [4, 2, [[[5, 6, 7], 5, 7]], 1], [3, 4, 6, [6, 4, 5]],
      ]


def flat_list_iter(lst):
    result = []
    stack = [lst]
    while stack:
        current = stack.pop(-1)
        if isinstance(current, list):
            stack.extend(current)
        else:
            result.append(current)
    result.reverse()
    return result


print(flat_list_iter(sp))
# [5, 7, 2, 4, 9, 5, 2, 5, ..., 4, 6, 6, 4, 5]


def flat_list_recur(lst):
    if lst == []:
    # if not lst:
        return lst
    if isinstance(lst[0], list):
        return flat_list_recur(lst[0]) + flat_list_recur(lst[1:])
    return lst[:1] + flat_list_recur(lst[1:])

print(flat_list_recur(sp))
# [5, 7, 2, 4, 9, 5, 2, 5, ..., 4, 6, 6, 4, 5]


# Задание 10
# Реализуйте алгоритм бинарного поиска с помощью итеративной и рекурсивной функций.
# Число задается с помощью randrange(2000), в списке хранятся числа от 1 до 1000,
# т.е. не во всех случаях заданное число будет присутствовать в списке.

from random import randrange

def binary_iter(lst, num):
    start, end, mid = 0, len(lst) - 1, 0

    while start <= end:
        mid = (end + start) // 2
        if lst[mid] < num:
            start = mid + 1
        elif lst[mid] > num:
            end = mid - 1
        else:
            return mid
    return None

sp = [i for i in range(1001)]
n = randrange(2000)

result = binary_iter(sp, n)

if result:
    print(f'Число найдено: {result}')
else:
    print('Такого числа нет в списке')

from random import randrange



def binary_recursive(lst, start, end, num):
    if end >= start:
        mid = (end + start) // 2
        if lst[mid] == num:  # граничный случай - элемент находится посередине
            return mid

        elif lst[mid] > num:  # рекурсивный случай - элемент находится слева
            return binary_recursive(lst, start, mid - 1, num)

        else:  # рекурсивный случай - элемент находится справа
            return binary_recursive(lst, mid + 1, end, num)

    else:  # граничный случай - элемент в списке не обнаружен
        return None


sp = [i for i in range(1001)]
n = randrange(2000)

result = binary_recursive(sp, 0, len(sp) - 1, n)

if result:
    print(f'Число найдено: {result}')
else:
    print('Такого числа нет в списке')
---------------------------------------------
# ПРАКТИКА LAMBDA

# Задание 1
# Напишите программу, которая получает от пользователя список, состоящий из целых чисел,
# и находит произведение его элементов. Решите задачу тремя способами:
#
# с помощью reduce и лямбда-функции;
# с math.prod();
# с использованием пользовательской функции.
from functools import reduce
from math import prod

def my_prod(lst):
    mult = 1
    for i in lst:
        mult *= i
    return mult


my_input = '3 5 6 7 8 2 4 3 4'
my_input = list(map(int, my_input.split()))
print(my_input)

print(reduce(lambda x, y: x * y, my_input))
print(prod(my_input))
print(my_prod(my_input))

# [3, 5, 6, 7, 8, 2, 4, 3, 4]
# 483840


# Задание 2
# Напишите программу для сортировки значений словаря в алфавитном порядке.

dict_ = {
    'фрукт': 'яблоко',
    'цвет': 'антрацит',
    'артикул': 'в5678',
    'модель': 'бабочка',
    'наименование': 'книга',
    'жанр': 'триллер'
}
sorted_dict = dict(sorted(dict_.items(), key=lambda item: item[1]))
print(sorted_dict)
# {
#     'цвет': 'антрацит',
#     'модель': 'бабочка',
#     'артикул': 'в5678',
#     'наименование': 'книга',
#     'жанр': 'триллер',
#     'фрукт': 'яблоко'
# }


# Задание 3
# Напишите программу, которая получает от пользователя список, и выводит
# в алфавитном порядке все слова, состоящие из 5 букв.
# Решите задачу двумя способами – с использованием анонимной функции и
# с помощью спискового включения.

my_input = 'физалис груша слива арбуз банан апельсин яблоко папайя'
my_input = my_input.split()

print(*sorted([i for i in my_input if len(i) == 5]))
print(*sorted(filter(lambda i: len(i) == 5, my_input)))

# арбуз банан груша слива
# арбуз банан груша слива


# Задание 4
# Напишите программу, которая:
#
# определяет текущую дату с помощью datetime.datetime.now();
# извлекает информацию о дне, месяце и годе с помощью анонимных функций;
# выводит день, месяц и год на экран.

import datetime

now = datetime.datetime.now()
date = [
    ['день', lambda x: x.day],
    ['месяц', lambda x: x.month],
    ['год', lambda x: x.year]
]
for i in date:
    print(f'{i[0]}: {i[1](now)}')


import datetime
now = str(datetime.datetime.now())
date = now.split()[0].split('-')
print(f'день: {date[2]}'
      f'\nмесяц: {date[1]}'
      f'\nгод:  {date[0]}'
      )

# день: 22
# месяц: 10
# год: 2024


# Задание 5
# Напишите программу, которая получает целое число n и
# выводит n первых элементов последовательности Фибоначчи.

from functools import reduce

fibonacci = lambda n: reduce(lambda x, n: x + [x[-1] + x[-2]], range(n - 2), [0, 1])
n = int(input())
print(*fibonacci(n))
# 0 1 1 2 3 5 8 13 21 34 55 89


# Задание 6
# Напишите программу, которая получает от пользователя две строки
# с целыми числами и находит пересечение строк
# (общие для обеих строк элементы) без использования множеств.

my_input1 = '3 6 7 8 9 2 1 0 12 45'
my_input1 = list(map(int, my_input1.split()))
my_input2 = '7 9 0 12 15 5 6 11 43'
my_input2 = list(map(int, my_input2.split()))

print([i for i in my_input1 if i in my_input2])
print(list(filter(lambda i: i in my_input2, my_input1)))


# Задание 7
# Напишите программу, которая сортирует полученную от пользователя
# строку с числами следующим образом:
#
# отрицательные числа идут после положительных;
# и положительные, и отрицательные числа упорядочены по возрастанию.

my_input = '-6 -1 3 -5 -15 4 1 9 8 6 -3 -4 12 -10 7'
my_input = list(map(int, my_input.split()))

print(*sorted(my_input, key=lambda i: 0 if i == 0 else -1 / i))


# Задание 8
# Напишите программу, которая получает от пользователя две строки с числами,
# и выводит третью строку с поэлементными суммами чисел из первой и второй строк.

my_input1 = '7 2 3 -5 6 7 0 1 12 45 9 33'
my_input2 = '32 87 12 -2 4 7 1 3 9 2 4 2'
my_input1 = list(map(int, my_input1.split()))
my_input2 = list(map(int, my_input2.split()))
print(*list(map(lambda x, y: x + y, my_input1, my_input2)))
# 39 89 15 -7 10 14 1 4 21 47 13 35

# Или:

for i, j in zip(my_input1, my_input2):
    print(i + j, end=' ')


# Задание 9
# Напишите программу, которая получает
# 1) строку с набором слов;
# 2) одно слово, не входящее в предыдущую строку,
# и находит все анаграммы слова в строке.

lst = 'каприз клоун колба колун крона уклон колыбель карта'.split()
word = 'кулон'
print(*list(filter(lambda i: sorted(i) == sorted(word), lst)))
print(*list(filter(lambda x: (set(word) == set(x)), lst)))

# клоун колун уклон


# Задание 10
# Напишите программу для проверки надежности пароля.
# Надежный пароль должен содержать не менее 9 символов;
# кроме того, в пароле должна быть хотя бы одна:
# буква в верхнем регистре;
# буква в нижнем регистре;
# цифра;
# и хотя бы один символа из набора !@#$%^&*()-+.

def check_password(passw):
    res_dict = [
    lambda passw: any(x.isupper() for x in passw) or
                  '\nВ пароле должна быть хотя бы одна буква в верхнем регистре',
    lambda passw: any(x.islower() for x in passw) or
                  '\nВ пароле должна быть хотя бы одна буква в нижнем регистре ',
    lambda passw: any(x.isdigit() for x in passw) or
                  '\nВ пароле должна быть хотя бы одна цифра',
    lambda passw: any(x in '!@#$%^&*()-+' for x in passw) or
                  '\nПароль должен содержать один из спецсимволов !@#$%^&*()-+',
    lambda passw: len(passw) >= 9 or
                  '\nПароль должен содержать не менее 9 символов']
    result = [x for x in [i(passw) for i in res_dict] if x != True]
    if not result:
        result.append('Надежный пароль')
    return result


st = input('Введите пароль для проверки: ')
print(*check_password(st))
---------------------------------------------
# ПРАКТИКА ФУНКЦИИ ВЫСШЕГО ПОРЯДКА, ДЕКОРАТОРЫ, ЗАМЫКАНИЯ

# Задание 1
# Напишите функцию высшего порядка, которая получает в качестве
# аргумента две функции первого порядка:
#
# Функцию для преобразования текста сообщения в верхний регистр.
# Функцию для преобразования текста сообщения в нижний регистр.
def make_upper(str_):
    return str_.upper()


def make_lower(str_):
    return str_.lower()


def transform(func_, str_):
    return func_(str_)


my_input = 'регистр ПРЕОБРАЗОВАН функцией, ПОЛУЧЕННОЙ в качестве АРГУМЕНТА'
print(transform(make_upper, my_input))
print(transform(make_lower, my_input))


# Задание 2
# Напишите функцию высшего порядка, которая может принимать функции
# float(), hex(), bin(), str() и содержит вложенную функцию первого порядка,
# которая конвертирует полученное от пользователя целое число n в соответствии
# с полученными функциями.
#
# Пример вывода для n = 25:
# Преобразуем полученное число 25 в типы:
# float => 25.0
# bin => 0b11001
# hex => 0x19
# str => 25

def number_to(function):
    def convert(n):
        return function(n)
    return convert


to_float = number_to(float)
to_bin = number_to(bin)
to_hex = number_to(hex)
to_str = number_to(str)

n = int(input())
print(f'Преобразуем полученное число {n} в типы:'
      f'\nfloat => {to_float(n)}'
      f'\nbin => {to_bin(n)}'
      f'\nhex => {to_hex(n)}'
      f'\nstr => {to_str(n)}'
      )


# Задание 3
# Напишите функцию высшего порядка, которая:
#
# - Определяет, состоит ли полученный от пользователя список
# из четного или нечетного количества чисел.
# - Возвращает функцию умножения элементов списка (в которой не
# используется math.prod()), если количество чисел четное.
# - Возвращает функцию суммирования (в которой не используется
# встроенная функция sum()), если количество чисел нечетное.

from functools import reduce


def convert_to_lst(*args):
    return (list(map(int, arg.split())) for arg in args)


def production(lst):
    prod = reduce(lambda x, y: x * y, lst)
    return f'Количество чисел четное, результат: {prod}'


def summa(lst):
    summ = reduce(lambda x, y: x + y, lst)
    return f'Количество чисел нечетное, результат: {summ}'


def higher_order(lst):
    if len(lst) % 2 == 0:
        return production
        # return production(lst)
    else:
        return summa
        # return summa(lst)


my_input_1 = '8 9 3 5 1 3 8 2 9'
my_input_2 = '7 3 2 8 9 1 2 3 4 6'

sp_1, sp_2 = convert_to_lst(my_input_1, my_input_2)

result = higher_order(sp_1) # тут возврат функции
print(result(sp_1))
result = higher_order(sp_2) # тут возврат функции
print(result(sp_2))
# print(higher_order(sp_1)) # а тут возврат результата функции
# print(higher_order(sp_2)) # а тут возврат результата функции


# Задание 4
# Напишите собственный аналог функции filter().
# Для отбора данных my_filter() должна, как и встроенная filter(),
# использовать функцию-предикат.
# Функция-предикат возвращает True или False в зависимости от критерия –
# в нашем случае это факт совпадения первой и последней букв слова в строке,
# полученной от пользователя.
def my_filter(f, lst):
    return [i for i in lst if f(i)]

def pre(str_):
    return str_[0] == str_[-1]


my_input = 'крюк арбуз торт абрикос кулак барабан рупор господин томат мадам'
my_input = my_input.split()
print(*my_filter(pre, my_input))

# ИЛИ:

def my_filter(f, line):
    return [i for i in line if f(i)]

stroka = 'крюк арбуз торт абрикос кулак барабан рупор господин томат мадам'
stroka = stroka.split()
print(*my_filter(lambda x: x[0] == x[-1], stroka))

# ИЛИ - МОЙ ВАРИАНТ ПОСЛЕ ОБМОЗГОВКИ

def check(str_):
    return str_[0] == str_[-1]


def my_filter(f):
    def medium(a):
        return [x for x in a if f(x)]
    return medium


my_list = 'крюк арбуз торт абрикос кулак барабан рупор господин томат мадам'.split()
x = my_filter(check)
print(*x(my_list))
# ЛИБО
print(*my_filter(check)(my_list))

# крюк торт кулак рупор томат мадам


# Задание 5
# Напишите собственный вариант функции-агрегатора reduce().
# Функция при вызове должна получать:
# - Функцию первого порядка для проведения операции умножения или сложения.
# - Список чисел от пользователя.
# - Начальное значение – 0 для операции суммирования, 1 для операции умножения.
def convert(arg):
    return list(map(int, arg.split()))


def my_reduce(operation, lst, init):
    result = init
    for i in lst:
        result = operation(result, i)
    return result


def add(x, y):
    return x + y


def mult(x, y):
    return x * y


my_list = '5 7 8 3 2 5 8 12 3 5 4 8 9'
my_list = convert(my_list)
print(my_reduce(add, my_list, 0)) # 79
print(my_reduce(mult, my_list, 1)) # 3483648000


# Задание 6
# В предыдущих статьях мы неоднократно использовали встроенную функцию zip()
# для параллельной итерации двух наборов данных.

# Напишите функцию высшего порядка, которая возвращает функции для:
#
# 1. Группировки параллельных элементов списков с помощью самописной my_zip().
# 2. Конкатенации элементов, сгрупированных my_zip().
# 3. Сложения элементов, сгруппированных my_zip().

# Примечание: следует учесть, что получаемые от пользователя списки могут
# быть разной длины.
# Как и встроенная zip(), my_zip() должна ограничивать размер возвращаемого
# списка длиной более короткого набора данных.

# (5, 4) (8, 5) (9, 6) (8, 2) (3, 3) (12, 2) (3, 5) (5, 9) (5, 4) (4, 12) (0, 9) (9, 3)
# 54 85 96 82 33 122 35 59 54 412 09 93
# 9 13 15 10 6 14 8 14 9 16 9 12
def convert(*args):
    return (list(map(int, arg.split())) for arg in args)


def zipp(*args):
    lst_1, lst_2 = args
    length = min(len(lst_1), len(lst_2))
    new_list = []
    for i in range(length):
        new_list.append((lst_1[i], lst_2[i]))
    return new_list


def conc(*args):
    lst_1, lst_2 = args
    length = min(len(lst_1), len(lst_2))
    new_list = []
    for i in range(length):
        new_list.append(str(lst_1[i]) + str(lst_2[i]))
    return new_list


def summa(*args):
    lst_1, lst_2 = args
    length = min(len(lst_1), len(lst_2))
    new_list = []
    for i in range(length):
        new_list.append(lst_1[i] + lst_2[i])
    return new_list


def my_zip(f):
    def medium(*args):
        return f(*args)
    return medium


input_1 = '5 8 9 8 3 12 3 5 5 4 0 9 6 1 23 6 12 30'
input_2 = '4 5 6 2 3 2 5 9 4 12 9 3'
lst_1, lst_2 = convert(input_1, input_2)

print(my_zip(zipp)(lst_1, lst_2))
print(my_zip(conc)(lst_1, lst_2))
print(my_zip(summa)(lst_1, lst_2))

# ИЛИ:

def my_zip(lst1, lst2):
    result = []
    for i in range(min(len(lst1), len(lst2))):
        result.append((lst1[i], lst2[i]))
    return result

def concatenation(lst1, lst2):
    result = []
    for i, j in my_zip(lst1, lst2):
        result.append(str(i) + str(j))
    return result

def add(lst1, lst2):
    result = []
    for i, j in my_zip(lst1, lst2):
        result.append(i + j)
    return result

sp1 = list(map(int, '5 8 9 8 3 12 3 5 5 4 0 9 6 1 23 6 12 30'.split()))
sp2 = list(map(int, '4 5 6 2 3 2 5 9 4 12 9 3'.split()))

def higher_order(function):
    return function(sp1, sp2)

print(*higher_order(my_zip))
print(*higher_order(concatenation))
print(*higher_order(add))

# ИЛИ:

def my_enumerate(lst, start=0):
    for i in lst:
        yield start, i
        start += 1


def my_filter(function, items):
    result = []
    for item in items:
        if function(item):
            result.append(item)
    return result


my_list = 'абрикос бюро газета банк коробка стол бобр ноутбук блокнот баланс абажур'.split()
letter = 'б'

for i, word in my_enumerate(my_filter(lambda x: x[0] == letter, my_list)):
    print(f'{i + 1}-e слово нового списка - {word}')


# Задание 8
# Напишите функцию высшего порядка, которая принимает две одноаргументные
# функции первого порядка и возвращает новую функцию.
# Эта функция принимает аргумент x и применяет к нему полученные функции
# в следующем порядке:
#
# function1(function2(x))
#
# К примеру, если передать в функцию высшего порядка эти функции
#
# def add(x):
#     return x + 10
#
# def multiply(x):
#     return x * 5
#
# И вызвать функцию так:
#
# print(super_function(add, float)('16'))
# print(super_function(tuple, multiply)((3, 4, 5)))
# print(super_function(str, multiply)('55'))
# print(super_function(list, multiply)((1, 2, 3)))
#
# Результат будет выглядеть следующим образом:
#
# 26.0
# (3, 4, 5, 3, 4, 5, 3, 4, 5, 3, 4, 5, 3, 4, 5)
# 5555555555
# [1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3]
def add(x):
    return x + 10

def multiply(x):
    return x * 5


def super_function(f1, f2):
    def medium(*args):
        return f1(f2(*args))
    return medium

# ИЛИ:

def super_function(f1, f2):
    return lambda x: f1(f2(x))


print(super_function(add, float)('16'))
print(super_function(tuple, multiply)((3, 4, 5)))
print(super_function(str, multiply)('55'))
print(super_function(list, multiply)((1, 2, 3)))
# 26.0
# (3, 4, 5, 3, 4, 5, 3, 4, 5, 3, 4, 5, 3, 4, 5)
# 5555555555
# [1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3]


# Задание 9
# Напишите декоратор, который будет подсчитывать количество позиционных и
# именованных аргументов, переданных в функцию первого порядка.

def decorator_func(f):
    def wrapper(*args, **kwargs):
        print(f'Функция получила позиционных аргументов: {len(args)}, '
              f'именованных аргументов: {len(kwargs)}')
        return f(*args, **kwargs)
    return wrapper

@decorator_func
def names_and_age(age1, age2, age3, name1, name2, name3):
    return f'У меня есть три сестры: {name1}, ей {age1} лет; ' \
           f'{name2}, ей {age2} лет; {name3} - ей {age3} лет\n'


print(
    names_and_age(
        12, 15, 13, name1='Света', name2='Маша', name3='Ира'
    )
)
# Функция получила позиционных аргументов: 3, именованных аргументов: 3
# У меня есть три сестры: Света, ей 12 лет; Маша, ей 15 лет; Ира - ей 13 лет


@decorator_func
def position_and_salary(sal1, sal2, sal3, sal4, pos1, pos2, pos3, pos4):
    return f'{pos1} получает {sal1} тыс, {pos2} получает {sal2} тыс, ' \
           f'{pos3} получает {sal3} тыс, {pos4} получает {sal4} тыс\n'


print(
    position_and_salary(
        320, 150, 230, 170, pos1='разработчик', pos2='тестировщик',
        pos3='девопс', pos4='сисадмин'
    )
)
# Функция получила позиционных аргументов: 4, именованных аргументов: 4
# разработчик получает 320 тыс, тестировщик получает 150 тыс, девопс получает 230 тыс,
# сисадмин получает 170 тыс


# Задание 10
# Напишите декоратор, который будет измерять производительность функций,
# создающих список с помощью этих методов:
#
# range()
# списковое включение
# append()
# конкатенация
# Среди показателей должны быть:
#
# Время работы функции.
# Текущее потребление памяти.
# Пиковое потребление памяти.
#

import tracemalloc
from time import perf_counter
from functools import wraps
import inspect


def time_memory_used(function):
    @wraps(function)
    def wrapper(*args, **kwargs):
        tracemalloc.start()
        start = perf_counter()
        result = function(*args, **kwargs)
        current, peak = tracemalloc.get_traced_memory()
        stop = perf_counter()
        print(f'Название функции: {function.__name__}')
        print(f'Использованный метод: {function.__doc__}')
        print(f'Текущее потребление памяти: {current / 10**6:.6f} мб \n'
              f'Пик использования памяти: {peak / 10**6:.6f} мб ')
        print(f'Операция заняла: {stop - start:.6f} секунд')
        tracemalloc.stop()
        return result
    return wrapper


@time_memory_used
def make_list_with_range():
    'range()'
    my_list = list(range(100000))
    # print(inspect.stack()) # Интересненько
    return f'Функция {inspect.stack()[0][3]} завершила работу \n{"-" * 48}'

@time_memory_used
def make_list_comprehension():
    'list comprehension'
    my_list = [l for l in range(100000)]
    return f'Функция {inspect.stack()[0][3]} завершила работу \n{"-" * 48}'


@time_memory_used
def make_list_with_append():
    'append()'
    my_list = []
    for item in range(100000):
        my_list.append(item)
    return f'Функция {inspect.stack()[0][3]} завершила работу \n{"-" * 48}'


@time_memory_used
def make_list_concatenation():
    'конкатенация'
    my_list = []
    for item in range(100000):
        my_list = my_list + [item]
    return f'Функция {inspect.stack()[0][3]} завершила работу \n{"-" * 48}'


print(make_list_with_range())
print(make_list_comprehension())
print(make_list_with_append())
print(make_list_concatenation())
#
# Название функции: make_list_with_range
# Использованный метод: range()
# Текущее потребление памяти: 0.034127 мб
# Пик использования памяти: 4.038928 мб
# Операция заняла: 0.092711 секунд
# Функция make_list_with_range завершила работу
# ------------------------------------------------
# Название функции: make_list_comprehension
# Использованный метод: list comprehension
# Текущее потребление памяти: 0.000526 мб
# Пик использования памяти: 3.994862 мб
# Операция заняла: 0.067124 секунд
# Функция make_list_comprehension завершила работу
# ------------------------------------------------
# Название функции: make_list_with_append
# Использованный метод: append()
# Текущее потребление памяти: 0.000522 мб
# Пик использования памяти: 3.994870 мб
# Операция заняла: 0.072619 секунд
# Функция make_list_with_append завершила работу
# ------------------------------------------------
# Название функции: make_list_concatenation
# Использованный метод: конкатенация
# Текущее потребление памяти: 0.000526 мб
# Пик использования памяти: 4.791808 мб
# Операция заняла: 21.387560 секунд
# Функция make_list_concatenation завершила работу
# ------------------------------------------------

---------------------------------------------
# Практика Классы
# Задание 1
# Напишите класс MusicAlbum, у которого есть:
#
# Атрибуты title, artist, release_year, genre, tracklist
# (название, исполнитель, год выхода, жанр, список треков.
# Метод play_random_track() для вывода случайного названия песни.
import random
from random import choice

class MusicAlbum:
    def __init__(self, title, artist, release_year, genre, tracklist):
        self.title = title
        self.artist = artist
        self.release_year = release_year
        self.genre = genre
        self.tracklist = tracklist

    def play_random_track(self):
        # track_num = choice(range(1, len(self.tracklist) + 1))
        track_num = random.randint(1, len(self.tracklist))
        track_name = self.tracklist[track_num - 1]
        print(f'Воспроизводится трек {track_num}: {track_name}')


album4 = MusicAlbum("Deutschland", "Rammstein", 2019, "Neue Deutsche Härte",
                    ["Deutschland", "Radio", "Zeig dich", "Ausländer", "Sex",
                     "Puppe", "Was ich liebe", "Diamant", "Weit weg", "Tattoo",
                     "Hallomann"])
print("Название:", album4.title)
print("Исполнитель:", album4.artist)
print("Год:", album4.release_year)
print("Жанр:", album4.genre)
print("Треки:", album4.tracklist)
album4.play_random_track()

# Название: Deutschland
# Исполнитель: Rammstein
# Год: 2019
# Жанр: Neue Deutsche Härte
# Треки: ['Deutschland', 'Radio', 'Zeig dich', 'Ausländer', 'Sex', 'Puppe', 'Was ich liebe',
# 'Diamant', 'Weit weg', 'Tattoo', 'Hallomann']
# Воспроизводится трек 7: Was ich liebe


# Задание 2
# Создайте класс Student, который имеет:
#
# атрибуты name, age, grade, scores (имя, возраст, класс, оценки);
# метод average_score – для вычисления среднего балла успеваемости.
class Student:
    def __init__(self, name, age, grade, scores):
        self.name = name
        self.age = age
        self.grade = grade
        self.scores = scores

    def average_score(self):
        av_score = sum(self.scores) / len(self.scores)
        return av_score

student2 = Student("Егор Данилов", 12, "5B", [5, 4, 4, 5])
print("Имя:", student2.name)
print("Возраст:", student2.age)
print("Класс:", student2.grade)
print("Оценки:", *student2.scores)
print("Средний балл:", student2.average_score())

# Имя: Егор Данилов
# Возраст: 12
# Класс: 5B
# Оценки: 5 4 4 5
# Средний балл: 4.5


# Задание 3
# Напишите класс Recipe с двумя методами:
#
# print_ingredients(self) – выводит список продуктов, необходимых для приготовления блюда;
# cook(self) – сообщает название выбранного рецепта и уведомляет о готовности блюда.
class Recipe:
    def __init__(self, name, ingredients):
        self.name = name
        self.ingredients = ingredients

    def print_ingredients(self):
        print(f'Ингредиенты для {self.name}')
        for i in self.ingredients:
            print(f'- {i}')

    def cook(self):
        print(f'Сегодня мы готовим {self.name}.')
        print(f'Выполняем инструкцию по приготовлению блюда {self.name}...')
        print(f'Блюдо {self.name} готово!')


# создаем рецепт спагетти болоньезе
spaghetti = Recipe("Спагетти болоньезе", ["Спагетти", "Фарш", "Томатный соус", "Лук", "Чеснок", "Соль"])
# печатаем список продуктов для рецепта спагетти
spaghetti.print_ingredients()
# готовим спагетти
spaghetti.cook()
# создаем рецепт для кекса
cake = Recipe("Кекс", ["Мука", "Яйца", "Молоко", "Сахар", "Сливочное масло", "Соль", "Ванилин"])
# печатаем рецепт кекса
cake.print_ingredients()
# готовим кекс
cake.cook()

# Ингредиенты для Спагетти болоньезе:
# - Спагетти
# - Фарш
# - Томатный соус
# - Лук
# - Чеснок
# - Соль
# Сегодня мы готовим Спагетти болоньезе.
# Выполняем инструкцию по приготовлению блюда Спагетти болоньезе...
# Блюдо Спагетти болоньезе готово!
# Ингредиенты для Кекс:
# - Мука
# - Яйца
# - Молоко
# - Сахар
# - Сливочное масло
# - Соль
# - Ванилин
# Сегодня мы готовим Кекс.
# Выполняем инструкцию по приготовлению блюда Кекс...
# Блюдо Кекс готово!


# Задание 4
# Напишите суперкласс Publisher (издательство) и два подкласса BookPublisher
# (книжное издательство) и NewspaperPublisher (газетное издательство).
#
# Родительский класс Publisher имеет два атрибута name и location
# (название, расположение) и два метода:
#
# get_info(self) – предоставляет информацию о названии и расположении издательства;
# publish(self, message) – выводит информацию об издании, которое находится в печати.

# Подклассы BookPublisher и NewspaperPublisher используют метод
# super().__init__(name, location) суперкласса для вывода информации
# о своих названии и расположении, и кроме того, имеют собственные атрибуты:
#
# BookPublisher – num_authors (количество авторов).
# NewspaperPublisher– num_pages (количество страниц в газете).
class Publisher:
    def __init__(self, name, location):
        self._name = name
        self._location = location

    def get_info(self):
        return f'{self._name} ({self._location})'

    def publish(self, message):
        print(f'Готовим {repr(message)} к публикации в '
              f'{self.get_info()}')


class BookPublisher(Publisher):
    def __init__(self, name, location, num_authors):
        super().__init__(name, location)
        self.num_authors = num_authors

    def publish(self, *args):
        print(f'Передаем рукопись {repr(args[0])}, '
              f'написанную автором {args[1]} '
              f'в {self.get_info()}')


class NewspaperPublisher(Publisher):
    def __init__(self, name, location, num_pages):
        super().__init__(name, location)
        self.num_pages = num_pages

    def publish(self, headline):
        print(f'Печатаем свежий номер со статьей {repr(headline)} '
              f'на главной странице в издательстве {self.get_info()}')


publisher = Publisher("АБВГД Пресс", "Москва")
publisher.publish("Справочник писателя")

book_publisher = BookPublisher("Важные Книги", "Самара", 52)
book_publisher.publish("Приключения Чебурашки", "В.И. Пупкин")

newspaper_publisher = NewspaperPublisher("Московские вести", "Москва", 12)
newspaper_publisher.publish("Новая версия Midjourney будет платной")

# Готовим "Справочник писателя" к публикации в АБВГД Пресс (Москва)
# Передаем рукопись 'Приключения Чебурашки', написанную автором
# В.И. Пупкин в издательство Важные Книги (Самара)
# Печатаем свежий номер со статьей "Новая версия Midjourney будет платной"
# на главной странице в издательстве Московские вести (Москва)


# Задание 5
# Создайте класс BankAccount, который имеет следующие свойства:
#
# balance – приватный атрибут для хранения текущего баланса счета;
# interest_rate –приватный атрибут для процентной ставки;
# transactions – приватный атрибут для списка всех операций, совершенных по счету.
# Класс BankAccount должен иметь следующие методы:
#
# deposit(amount) – добавляет сумму к балансу и регистрирует транзакцию;
# withdraw(amount) – вычитает сумму из баланса и записывает транзакцию;
# add_interest()– добавляет проценты к счету на основе interest_rate и записывает транзакцию;
# history()– печатает список всех операций по счету.
class BankAccount:
    def __init__(self, balance, interest_rate, transactions=None):
        self.__balance = balance
        self.__interest_rate = interest_rate
        if transactions is None:
            self.__transactions = []

    def deposit(self, amount):
        self.__balance += amount
        self.__transactions.append(
            f'Внесение наличных на счет: {amount}'
        )

    def withdraw(self, amount):
        if self.__balance >= amount:
            self.__balance -= amount
            self.__transactions.append(
                f'Снятие наличных: {amount}'
            )
        else:
            print("Недостаточно средств на счете")

    def add_interest(self):
        interest = self.__balance * self.__interest_rate
        self.__balance += interest
        self.__transactions.append(
            f'Начислены проценты по вкладу: {interest}'
        )

    def history(self):
        for i in self.__transactions:
            print(i)

# создаем объект счета с балансом 100000 и процентом по вкладу 0.05
account = BankAccount(100000, 0.05)
# вносим 15 тысяч на счет
account.deposit(15000)
# снимаем 7500 рублей
account.withdraw(7500)
# начисляем проценты по вкладу
account.add_interest()
# печатаем историю операций
account.history()

# Внесение наличных на счет: 15000
# Снятие наличных: 7500
# Начислены проценты по вкладу: 5375.0


# Задание 6
# Создайте класс Employee (сотрудник), который имеет следующие приватные
# свойства:
#
# name – имя сотрудника;
# age – возраст;
# salary – оклад;
# bonus – премия.
# Класс Employee должен иметь следующие методы:
#
# get_name()– возвращает имя сотрудника;
# get_age()– возвращает возраст;
# get_salary() – возвращает зарплату сотрудника;
# set_bonus(bonus) – устанавливает свойство bonus;
# get_bonus() – возвращает бонус для сотрудника;
# get_total_salary() – возвращает общую зарплату сотрудника (оклад + бонус).
class Employee:
    def __init__(self, name, age, salary):
        self.__name = name
        self.__age = age
        self.__salary = salary
        self.__bonus = 0

    def get_name(self):
        return self.__name

    def get_age(self):
        return self.__age

    def get_salary(self):
        return self.__salary

    def set_bonus(self, bonus):
        self.__bonus = bonus

    def get_bonus(self):
        return self.__bonus

    def get_total_salary(self):
        total = self.__salary + self.__bonus
        return total

# создаем сотрудника с именем, возрастом и зарплатой
employee = Employee("Марина Арефьева", 30, 90000)
# устанавливаем бонус для сотрудника
employee.set_bonus(15000)
# выводим имя, возраст, зарплату, бонус и общую зарплату сотрудника
print("Имя:", employee.get_name())
print("Возраст:", employee.get_age())
print("Зарплата:", employee.get_salary())
print("Бонус:", employee.get_bonus())
print("Итого начислено:", employee.get_total_salary())

# Имя: Марина Арефьева
# Возраст: 30
# Зарплата: 90000
# Бонус: 15000
# Итого начислено: 105000


# Задание 7
# Напишите класс Animal, обладающий свойствами name, species, legs,
# в которых хранятся данные о кличке, виде и количестве ног животного.
# Класс также должен иметь два метода – voice() и move(), которые сообщают
# о том, что животное подает голос и двигается.
#
# Создайте два подкласса – Dog и Bird. Подкласс Dog имеет атрибут breed (порода)
# и метод bark(), который сообщает о том, что собака лает.
# Подкласс Bird обладает свойством wingspan (размах крыльев) и методом fly(),
# который уведомляет о полете птицы.
class Animal:
    def __init__(self, name, species, legs):
        self.name = name
        self.species = species
        self.legs = legs

    def voice(self):
        print(f'{self.name} подает голос')

    def move(self):
        print(f'{self.name} дергает хвостом')


class Dog(Animal):
    def __init__(self, name, breed, legs):
        super().__init__(name, breed, legs)
        self.breed = breed

    def bark(self):
        print(f'{self.species} {self.name} лает')


class Bird(Animal):
    def __init__(self, name, species, wingspan):
        super().__init__(name, species, wingspan)
        self.wingspan = wingspan

    def fly(self):
        print(f'{self.species} {self.name} летает')


dog = Dog("Геральт", "доберман", 4)
bird = Bird("Вася", "попугай", 2)
dog.voice()
bird.voice()
dog.move()
bird.move()
dog.bark()
bird.fly()

# Геральт подает голос
# Вася подает голос
# Геральт дергает хвостом
# Вася дергает хвостом
# доберман Геральт лает
# попугай Вася летaeт


# Задание 8
# Создайте класс Shape (геометрическая фигура) со свойствами name и color
# (название и цвет).
# У этого класса должны быть три подкласса – Circle (окружность),
# Rectangle (прямоугольник), и Triangle (треугольник).
# Каждый подкласс наследует атрибут color и метод describe()
# родительского класса Shape, и при этом имеет дополнительные свойства и методы:
#
# Circle – атрибут radius и метод area() для вычисления площади.
# Rectangle – атрибуты length и width, свой метод area().
# Triangle – атрибуты base и height (основание и высота),
# собственный метод area().
class Shape:
    def __init__(self, color):
        self.color = color

    def describe(self):
        print(
            f"Это геометрическая фигура, цвет - {self.color}."
        )


class Circle(Shape):
    def __init__(self, color, radius):
        super().__init__(color)
        self.radius = radius

    def area(self):
        return 3.14 * self.radius ** 2

    def describe(self):
        super().describe()
        print(
            f"Это окружность. "
            f"Радиус - {self.radius} см, "
            f"цвет - {self.color}."
        )


class Rectangle(Shape):
    def __init__(self, color, length, width):
        super().__init__(color)
        self.length = length
        self.width = width

    def area(self):
        return self.width * self.length

    def describe(self):
        super().describe()
        print(
            f"Это {self.color} прямоугольник. "
            f"Длина - {self.length} см, "
            f"ширина - {self.width} см."
        )


class Triangle(Shape):
    def __init__(self, color, base, height):
        super().__init__(color)
        self.base = base
        self.height = height

    def area(self):
        return self.base * self.height / 2

    def describe(self):
        super().describe()
        print(
            f"Это {self.color} треугольник с основанием {self.base} см "
            f"и высотой {self.height} см."
        )


circle = Circle("красный", 5)
rectangle = Rectangle("синий", 3, 4)
triangle = Triangle("фиолетовый", 6, 8)
circle.describe()
rectangle.describe()
triangle.describe()
print(
    f"Площадь треугольника {triangle.area()}, "
    f"окружности {circle.area()}, "
    f"прямоугольника {rectangle.area()} см.")

# Это геометрическая фигура, цвет - красный.
# Это окружность. Радиус - 5 см, цвет - красный.
# Это геометрическая фигура, цвет - синий.
# Это синий прямоугольник. Длина - 3 см, ширина - 4 см.
# Это геометрическая фигура, цвет - фиолетовый.
# Это фиолетовый треугольник с основанием 6 см и высотой 8 см.
# Площадь треугольника 24.0, окружности 78.5, прямоугольника 12 см.


# Задание 9
# Для ПО кондитерской фабрики нужно написать родительский класс Candy (Конфеты).
# Этот класс имеет атрибуты name, price, weight (наименование, цена, вес).
#
# Подклассы Chocolate, Gummy, HardCandy (шоколад, жевательный мармелад, леденец)
# наследуют все атрибуты суперкласса Candy.

# Кроме того, у них есть и свои атрибуты:
#
# Chocolate – cocoa_percentage (процент содержания какао) и
# chocolate_type (сорт шоколада).
# Gummy – flavor и shape (вкус и форма).
# HardCandy – flavor и filled (вкус и начинка).
class Candy:
    def __init__(self, name, price, weight):
        self.name = name
        self.price = price
        self.weight = weight


class Chocolate(Candy):
    def __init__(self, name, price, weight, cocoa_percentage, chocolate_type):
        super().__init__(name, price, weight)
        self.cocoa_percentage = cocoa_percentage
        self.chocolate_type = chocolate_type

class Gummy(Candy):
    def __init__(self, name, price, weight, flavor, shape):
        super().__init__(name, price, weight)
        self.flavor = flavor
        self.shape = shape


class HardCandy(Candy):
    def __init__(self, name, price, weight, flavor, filled):
        super().__init__(name, price, weight)
        self.flavor = flavor
        # if filled is None:
        self.filled = filled


chocolate = Chocolate(
    name="Швейцарские луга",
    price=325.50,
    weight=220,
    cocoa_percentage=40,
    chocolate_type="молочный"
)
gummy = Gummy(
    name="Жуй-жуй",
    price=76.50,
    weight=50,
    flavor="вишня",
    shape="медведь"
)
hard_candy = HardCandy(
    name="Crazy Фрукт",
    price=35.50,
    weight=25,
    flavor="манго",
    filled=True
)

print("Шоколадные конфеты:")
print(f"Название конфет: {chocolate.name}")
print(f"Стоимость: {chocolate.price} руб")
print(f"Вес брутто: {chocolate.weight} г")
print(f"Процент содержания какао: {chocolate.cocoa_percentage}")
print(f"Тип шоколада: {chocolate.chocolate_type}")
print("\nМармелад жевательный:")
print(f"Название конфет: {gummy.name}")
print(f"Стоимость: {gummy.price} руб")
print(f"Вес брутто: {gummy.weight} г")
print(f"Вкус: {gummy.flavor}")
print(f"Форма: {gummy.shape}")
print("\nФруктовые леденцы:")
print(f"Название конфет: {hard_candy.name}")
print(f"Стоимость: {hard_candy.price} руб")
print(f"Вес брутто: {hard_candy.weight} г")
print(f"Вкус: {hard_candy.flavor}")
print(f"Начинка: {hard_candy.filled}")

# Шоколадные конфеты:
# Название конфет: Швейцарские луга
# Стоимость: 325.5 руб
# Вес брутто: 220 г
# Процент содержания какао: 40
# Тип шоколада: молочный
#
# Мармелад жевательный:
# Название конфет: Жуй-жуй
# Стоимость: 76.5 руб
# Вес брутто: 50 г
# Вкус: вишня
# Форма: медведь
#
# Фруктовые леденцы:
# Название конфет: Crazy Фрукт
# Стоимость: 35.5 руб
# Вес брутто: 25 г
# Вкус: манго
# Начинка: True


# Задание 10
# Для военной игры-стратегии нужно написать класс Soldier (солдат).
# Класс имеет атрибуты name, rank и service_number
# (имя, воинское звание, порядковый номер),
# причем звание и номер – приватные свойства.
#
# Напишите методы для:
#
# получения воинского звания;
# подтверждения порядкового номера;
# повышения в звании;
# понижения в звании.
# Кроме того, нужно создать декоратор для вывода информации о персонаже.
RANKS = ["рядовой", "ефрейтор", "младший сержант", "сержант", "старший сержант",
         "прапорщик", "старший прапорщик"]

def print_info(cls):
    class NewClass(cls):
        def __init__(self, *args, **kwargs):
            super().__init__(*args, **kwargs)
            print(
                f"Создан новый игровой персонаж типа {cls.__name__} "
                f"с атрибутами: {self.__dict__}"
            )

        # def verify_service_number(self, *args, **kwargs):
        #     super().verify_service_number(*args, **kwargs)
        #     print(f'ggg')

        def get_rank(self):
            print(
                f"Персонаж {self.name} имеет звание "
                f"{self._Soldier__rank}"
            )

        def promote(self):
            super().promote()
            print(
                f"{self.name} повышен в звании, "
                f"он теперь {self._Soldier__rank}"
            )

        def demote(self):
            super().demote()
            print(
                f"{self.name} понижен в звании, "
                f"он теперь {self._Soldier__rank}"
            )

    return NewClass


@print_info
class Soldier:
    def __init__(self, name, rank, service_number):
        self.name = name
        self.__rank = rank
        self.__service_number = service_number

    def verify_service_number(self, service_number):
        return self.__service_number == service_number

    def promote(self):
        if self.__rank in RANKS[:-1]:
            self.__rank = RANKS[RANKS.index(self.__rank) + 1]

    def demote(self):
        if self.__rank in RANKS[1:]:
            self.__rank = RANKS[RANKS.index(self.__rank) - 1]


soldier1 = Soldier("Иван Сусанин", "рядовой", "12345")
# soldier1.verify_service_number('xxx')
soldier1.get_rank()
soldier1.promote()
soldier1.demote()

# Создан новый игровой персонаж типа Soldier с атрибутами: {
#     'name': 'Иван Сусанин',
#     '_Soldier__rank': 'рядовой',
#     '_Soldier__service_number': '12345'
# }
# Персонаж Иван Сусанин имеет звание рядовой
# Иван Сусанин повышен в звании, он теперь ефрейтор
# Иван Сусанин понижен в звании, он теперь рядовой

---------------------------------------------
# ПРАКТИКА АБСТРАКЦИЯ И ПОЛИМОРФИЗМ

# Задание 1
# В далекой-далекой галактике Федерация ведет ожесточенную войну с клингонами.
# Звездолеты Федерации оснащены мощными фазерами, а клингонские корабли – смертоносными
# фотонными торпедами.
#
# Обе стороны разработали усовершенствованные варп-двигатели для перемещения со
# сверхсветовой скоростью, и оборудовали свои корабли системами самоуничтожения
# на случай чрезвычайной ситуации.
#
# Для игры, посвященной этой войне, нужно создать абстрактный класс Starship с
# методами warp_speed(), fire_weapon() и self_destruct(). Кроме того, нужно
# создать два подкласса FederationStarship и KlingonWarship, которые наследуют
# абстрактные методы Starship и реализуют свои собственные версии методов warp_speed(),
# fire_weapon() и self_destruct().
from abc import ABC, abstractmethod

class Starship(ABC):
    @abstractmethod
    def warp_speed(self):
        pass

    @abstractmethod
    def fire_weapon(self):
        pass

    @abstractmethod
    def self_destruct(self):
        print('Запускаю систему самоуничтожения...')


class FederationStarship(Starship):
    def warp_speed(self):
        print('Включить варп-двигатели!')

    def fire_weapon(self):
        print('Стрелять из фазеров!')

    def self_destruct(self):
        super().self_destruct()


class KlingonWarship(Starship):
    def warp_speed(self):
        print('Включить маскировочное устройство!')

    def fire_weapon(self):
        print('Выпустить фотонные торпеды!')

    def self_destruct(self):
        super().self_destruct()


enterprise = FederationStarship()
bird_of_prey = KlingonWarship()

enterprise.warp_speed()
bird_of_prey.warp_speed()

enterprise.fire_weapon()
bird_of_prey.fire_weapon()

enterprise.self_destruct()
bird_of_prey.self_destruct()

# Включить варп-двигатели!
# Включить маскировочное устройство!
# Стрелять из фазеров!
# Выпустить фотонные торпеды!
# Запускаю систему самоуничтожения...
# Запускаю систему самоуничтожения...


# Задание 2
# Для ПО ресторана нужно разработать модуль, помогающий контролировать
# использование фруктов и овощей на кухне.
# Создайте абстрактный класс Ingredient с методами get_name() и
# get_quantity(). Затем создайте два подкласса Vegetable и Fruit,
# которые наследуют абстрактные методы от Ingredient и реализуют
# свои собственные версии методов get_name() и get_quantity().
from abc import ABC, abstractmethod


class Ingredient(ABC):
    def __init__(self, name, quantity):
        self._name = name
        self._quantity = quantity

    @abstractmethod
    def get_name(self):
        pass

    @abstractmethod
    def get_quantity(self):
        pass


class Vegetable(Ingredient):
    def get_name(self):
        return f'{self._name}'

    def get_quantity(self):
        return f'{self._quantity} кг'


class Fruit(Ingredient):
    def get_name(self):
        return f'{self._name}'

    def get_quantity(self):
        return f'{self._quantity} кг'


carrot = Vegetable("Морковь", 5)
apple = Fruit("Яблоки", 10)

print(carrot.get_name())
print(carrot.get_quantity())

print(apple.get_name())
print(apple.get_quantity())

# Морковь
# 5 кг
# Яблоки
# 10 кг


# Задание 3

# Для военной стратегии необходимо создать абстрактный класс Soldier.
# Каждый солдат должен уметь двигаться, защищаться и атаковать,
# поэтому Soldier имеет три абстрактных метода: move(), attack() и defend().
# Два конкретных класса, Infantry (пехота) и Cavalry (кавалерия),
# будут наследовать и реализовывать эти методы.
#
# В игре также должен быть класс Army, который будет добавлять солдат в
# армию и выполнять операции атаки и защиты.
#
# Чтобы гарантировать, что используются только экземпляры класса Soldier,
# нужно создать декоратор validatesoldier, который будет проверять
# тип объекта.
#
# Если объект не является экземпляром класса Soldier, декоратор выдаст ошибку
# TypeError.
# Декоратор будет применяться к методам move(), attack() и defend() классов
# Infantry и Cavalry.
from abc import ABC, abstractmethod


def validatesoldier(func):
    def wrapper(self):
    # def wrapper(*args):
        if not isinstance(self, Soldier):
        # if not isinstance(args[0], Soldier):
            raise TypeError("Объект не является экземпляром Soldier")
        return func(self)
        # return func(*args)
    return wrapper


class Soldier(ABC):
    @abstractmethod
    def move(self):
        pass

    @abstractmethod
    def attack(self):
        pass

    @abstractmethod
    def defend(self):
        pass


class Infantry(Soldier):
    @validatesoldier
    def move(self):
        print('Пехота передвигается в пешем порядке')

    @validatesoldier
    def attack(self):
        print('Пехота участвует в ближнем бою')

    @validatesoldier
    def defend(self):
        print('Пехота держит строй')


class Cavalry(Soldier):
    @validatesoldier
    def move(self):
        print('Кавалерия передвигается верхом')

    @validatesoldier
    def attack(self):
        print('Кавалерия переходит в атаку')

    @validatesoldier
    def defend(self):
        print('Кавалерия защищает фланги')


class Army:
    def __init__(self):
        self.soldiers = []

    def add_soldier(self, soldier):
        self.soldiers.append(soldier)

    def attack(self):
        for soldier in self.soldiers:
            soldier.move()
            soldier.attack()

    def defend(self):
        for soldier in self.soldiers:
            soldier.move()
            soldier.defend()


army = Army()
army.add_soldier(Infantry())
army.add_soldier(Cavalry())
army.add_soldier(Infantry())
army.add_soldier(Cavalry())

army.attack()
army.defend()

# Пехота передвигается в пешем порядке
# Пехота участвует в ближнем бою
# Кавалерия передвигается верхом
# Кавалерия переходит в атаку
# Пехота передвигается в пешем порядке
# Пехота участвует в ближнем бою
# Кавалерия передвигается верхом
# Кавалерия переходит в атаку
# Пехота передвигается в пешем порядке
# Пехота держит строй
# Кавалерия передвигается верхом
# Кавалерия защищает фланги
# Пехота передвигается в пешем порядке
# Пехота держит строй
# Кавалерия передвигается верхом
# Кавалерия защищает фланги


# Задание 4
# Палеонтологам, работающим в заповеднике для динозавров, понадобилось ПО
# для отслеживания множества травоядных и плотоядных подопечных.
# Данные, которые нужно учитывать по каждому динозавру – имя, вид, рост,
# вес и рацион питания.
#
# Создайте абстрактный класс Dinosaur с методами get_personal_name(),
# get_breed(), get_height(), get_weight() и get_diet().
# Затем создайте два подкласса Carnivore (плотоядный) и Herbivore
# (травоядный), которые наследуют методы Dinosaur и реализуют свои
# собственные версии get_personal_name(), get_breed(), get_height(),
# get_weight() и get_diet().
#
# Кроме того, создайте класс DinosaurPark, который содержит список
# динозавров и имеет методы list_dinosaurs(), list_carnivores() и
# list_herbivores() для вывода списков
# a) всех динозавров,
# b) плотоядных и
# c) травоядных особей.
from abc import ABC, abstractmethod


class Dinosaur(ABC):
    @abstractmethod
    def get_personal_name(self):
        pass

    @abstractmethod
    def get_breed(self):
        pass

    @abstractmethod
    def get_height(self):
        pass

    @abstractmethod
    def get_weight(self):
        pass

    @abstractmethod
    def get_diet(self):
        pass


class Carnivore(Dinosaur):
    def __init__(self, breed, name, height, weight):
        self._name = name
        self._breed = breed
        self._height = height
        self._weight = weight

    def get_personal_name(self):
        return self._name

    def get_breed(self):
        return self._breed

    def get_height(self):
        return self._height

    def get_weight(self):
        return self._weight

    def get_diet(self):
        return 'Плотоядный'


class Herbivore(Dinosaur):
    def __init__(self, breed, name, height, weight):
        self._name = name
        self._breed = breed
        self._height = height
        self._weight = weight

    def get_personal_name(self):
        return self._name

    def get_breed(self):
        return self._breed

    def get_height(self):
        return self._height

    def get_weight(self):
        return self._weight

    def get_diet(self):
        return 'Травоядный'


class DinosaurPark:
    def __init__(self):
        self.dinosaurs = []

    def add_dinosaur(self, saur):
        self.dinosaurs.append(
            [
                saur.get_personal_name(),
                saur.get_breed(),
                saur.get_height(),
                saur.get_weight(),
                saur.get_diet()
            ]
        )

    def list_dinosaurs(self):
        return self.dinosaurs

    def list_carnivores(self):
        return [i for i in self.dinosaurs if i[4] == 'Плотоядный']

    def list_herbivores(self):
        return [i for i in self.dinosaurs if i[4] == 'Травоядный']

    # ИЛИ ВАРИАНТ УЧЕБНИКА

# class DinosaurPark:
#     def __init__(self):
#         self.dinosaurs = []
#
#     def add_dinosaur(self, dinosaur):
#         self.dinosaurs.append(dinosaur)
#
#     def list_dinosaurs(self):
#         return [
#             (
#                 dinosaur.get_personal_name(),
#                 dinosaur.get_breed(),
#                 dinosaur.get_height(),
#                 dinosaur.get_weight(),
#                 dinosaur.get_diet()
#             ) for dinosaur in self.dinosaurs
#         ]
#
#     def list_carnivores(self):
#         return [
#             (
#                 dinosaur.get_personal_name(),
#                 dinosaur.get_breed(),
#                 dinosaur.get_height(),
#                 dinosaur.get_weight()
#             ) for dinosaur in self.dinosaurs if isinstance(
#                 dinosaur,
#                 Carnivore
#             )
#         ]
#
#     def list_herbivores(self):
#         return [
#             (
#                 dinosaur.get_personal_name(),
#                 dinosaur.get_breed(),
#                 dinosaur.get_height(),
#                 dinosaur.get_weight()
#             ) for dinosaur in self.dinosaurs if isinstance(
#                 dinosaur,
#                 Herbivore
#             )
#         ]


t_rex = Carnivore('Тираннозавр', 'Рекс', 4800, 560)
velociraptor = Carnivore('Велоцираптор', 'Зубастик', 30, 70)
stegosaurus = Herbivore('Стегозавр', 'Стегга', 7100, 420)
triceratops = Herbivore('Трицератопс', 'Трипси', 8000, 290)

park = DinosaurPark()

park.add_dinosaur(t_rex)
park.add_dinosaur(velociraptor)
park.add_dinosaur(stegosaurus)
park.add_dinosaur(triceratops)


for dinosaur in park.list_dinosaurs():
    print(f'Имя: {dinosaur[0]}\n'
    f'Вид: {dinosaur[1]}\n'
    f'Вес: {dinosaur[2]} кг\n'
    f'Рост: {dinosaur[3]} см\n'
    f'Рацион: {dinosaur[4]}\n')

# Имя: Рекс
# Вид: Тираннозавр
# Вес: 4800 кг
# Рост: 560 см
# Рацион: Плотоядный
#
# Имя: Зубастик
# Вид: Велоцираптор
# Вес: 30 кг
# Рост: 70 см
# Рацион: Плотоядный
#
# Имя: Стегга
# Вид: Стегозавр
# Вес: 7100 кг
# Рост: 420 см
# Рацион: Травоядный
#
# Имя: Трипси
# Вид: Трицератопс
# Вес: 8000 кг
# Рост: 290 см
# Рацион: Травоядный


# Задание 5
# Для учета музыкальных инструментов в оркестре нужно создать
# абстрактный класс Instrument с методами get_name(), get_type(),
# get_sound() и play().
#
# Два подкласса StringedInstrument (струнные)
# и PercussionInstrument (ударные) наследуют методы Instrument и
# реализуют свои собственные версии методов get_name(),
# get_type(), get_sound() и play().

# Кроме того, необходимо реализовать класс Orchestra: он добавляет новые
# инструменты и имеет методы list_instruments(), list_stringed_instruments(),
# list_percussion_instruments(), которые выводят списки
# a) всех инструментов,
# b) ударных,
# c) струнных.
from abc import ABC, abstractmethod


class Instrument(ABC):
    @abstractmethod
    def get_name(self):
        pass

    @abstractmethod
    def get_type(self):
        pass

    @abstractmethod
    def get_sound(self):
        pass

    @abstractmethod
    def play(self):
        pass


class StringedInstrument(Instrument):
    def __init__(self, name, type, sound):
        self.name = name
        self.type = type
        self.sound = sound

    def get_name(self):
        return self.name

    def get_type(self):
        return self.type

    def get_sound(self):
        return self.sound

    def play(self):
        return f'Звучит {self.type} {self.name}'


class PercussionInstrument(Instrument):
    def __init__(self, name, type, sound):
        self.name = name
        self.type = type
        self.sound = sound

    def get_name(self):
        return self.name

    def get_type(self):
        return self.type

    def get_sound(self):
        return self.sound

    def play(self):
        return f'Звучит {self.type} {self.name}'


class Orchestra:
    def __init__(self):
        self.instruments = []
    def add_instrument(self, instrument):
        self.instruments.append(instrument)

    def list_instruments(self):
        return[i.get_name() for i in self.instruments]

    def list_stringed_instruments(self):
        return [i.get_name() for i in self.instruments if isinstance(
            i,
            StringedInstrument
        )
                ]

    def list_percussion_instruments(self):
        return [i.get_name() for i in self.instruments if isinstance(
            i,
            PercussionInstrument
        )
                ]


chello = StringedInstrument("виолончель", "струнный инструмент", "Strum")
maracas = PercussionInstrument("маракасы", "ударный инструмент", "Maracas")
violin = StringedInstrument("скрипка", "струнный инструмент", "Virtuso")
drums = PercussionInstrument("барабан", "ударный инструмент", "Beat")

orchestra = Orchestra()
orchestra.add_instrument(chello)
orchestra.add_instrument(maracas)
orchestra.add_instrument(violin)
orchestra.add_instrument(drums)

print("В оркестрe есть инструменты:", ', '.join(orchestra.list_instruments()))
print("Струнные инструменты:", ', '.join(orchestra.list_stringed_instruments()))
print("Ударные инструменты:", ', '.join(orchestra.list_percussion_instruments()))

print(chello.play())
print(drums.play())

# В оркестрe есть инструменты: виолончель, маракасы, скрипка, барабан
# Струнные инструменты: виолончель, скрипка
# Ударные инструменты: маракасы, барабан
# Звучит струнный инструмент виолончель
# Звучит ударный инструмент барабан


# Задание 6
# Напишите класс FilmCatalogue (каталог фильмов), который отвечает
# за ведение фильмотеки.

# FilmCatalogue должен поддерживать различные типы кинокартин, чтобы
# пользователи могли искать фильмы по определенному жанру.
# Для этого необходимо создать новые классы для различных жанров
# (например, Horror, Action, Romance), которые наследуют класс Movie
# и переопределяют метод play() для вывода информации о том, к какому
# жанру относится фильм.
from abc import ABC, abstractmethod
from random import choice


class Movie(ABC):
    def __init__(self, title, director):
        self.title = title
        self.director = director

    @abstractmethod
    def play(self):
        print(f"Собираемся смотреть фильм '{self.title}' реж. {self.director}.")


class Horror(Movie):
    def play(self):
        return f'Включаем фильм ужасов {repr(self.title)}, {self.director}'


class Action(Movie):
    def play(self):
        return f'Включаем боевик {repr(self.title)}, {self.director}'


class Romance(Movie):
    def play(self):
        return f'Включаем мелодраму {repr(self.title)}, {self.director}'


class Drama(Movie):
    def play(self):
        return f'Включаем драму {repr(self.title)}, {self.director}'


class Comedy(Movie):
    def play(self):
        return f'Включаем комедию {repr(self.title)}, {self.director}'


class FilmCatalogue:
    def __init__(self):
        self.movies = []

    def add_movie(self, movie):
        self.movies.append(movie)

    def play_all_movies(self):
        for movie in self.movies:
            print(movie.play())

    def search_movies_by_genre(self, genre):
        return [i for i in self.movies if isinstance(i, genre)]

    def play_movies_by_genre(self, genre):
        print(choice([i.play() for i in self.movies if isinstance(i, genre)]))

my_catalogue = FilmCatalogue()

my_catalogue.add_movie(Drama("Крестный отец", "Френсис Ф. Коппола"))
my_catalogue.add_movie(Comedy("Ночные игры", "Джон Фрэнсис Дейли, Джонатан М. Голдштейн"))
my_catalogue.add_movie(Horror("Дракула Брэма Стокера", "Френсис Ф. Коппола"))
my_catalogue.add_movie(Action("Крушение", "Жан-Франсуа Рише"))
my_catalogue.add_movie(Romance("Честная куртизанка", "Маршалл Херсковиц"))

my_catalogue.play_all_movies()

print(f"\nНайдены фильмы ужасов:")
for movie in my_catalogue.search_movies_by_genre(Horror):
    print(movie.title)

print(f"\nЗапускаем фильм из жанра 'Мелодрамы':")
my_catalogue.play_movies_by_genre(Romance)

# Включаем драму 'Крестный отец' реж. Френсис Ф. Коппола.
# Включаем комедию 'Ночные игры' реж. Джон Фрэнсис Дейли, Джонатан М. Голдштейн.
# Включаем фильм ужасов 'Дракула Брэма Стокера' реж. Френсис Ф. Коппола.
# Включаем боевик 'Крушение' реж. Жан-Франсуа Рише.
# Включаем мелодраму 'Честная куртизанка' реж. Маршалл Херсковиц.
#
# Найдены фильмы ужасов:
# Дракула Брэма Стокера
#
# Запускаем фильм из жанра 'Мелодрамы':
# Включаем мелодраму 'Честная куртизанка' реж. Маршалл Херсковиц.


# Задание 7
# Для CRM винодельни нужно написать модуль, отвечающий за учет
# красных, белых и розовых вин, каждое из которых имеет свое название,
# сорт винограда, год и температуру подачи.
#
# Создайте базовый класс Wine с атрибутами name, grape и year.
# Затем создайте три подкласса RedWine, WhiteWine и RoseWine,
# которые наследуют методы и атрибуты от Wine и реализуют свои
# собственные версии метода serve().
# Кроме того, создайте класс Winery, который ведет список вин и имеет метод
# serve_wines(), вызывающий метод serve() для каждого вина.
from abc import ABC, abstractmethod

class Wine(ABC):
    def __init__(self, name, grape, year):
        self.name = name
        self.grape = grape
        self.year = year

    def serve(self):
        pass


class RedWine(Wine):
    def serve(self):
        print(
            f"Красное вино '{self.name}', сделанное из винограда сорта {self.grape} "
            f"в {self.year} году, рекомендуем подавать комнатной температуры.")


class WhiteWine(Wine):
    def serve(self):
        print(
            f"Белое вино '{self.name}', сделанное из винограда сорта {self.grape} "
            f"в {self.year} году, рекомендуем подавать комнатной температуры.")


class RoseWine(Wine):
    def serve(self):
        print(
            f"Розовое вино '{self.name}', сделанное из винограда сорта {self.grape} "
            f"в {self.year} году, рекомендуем подавать комнатной температуры.")


class Winery:
    def __init__(self):
        self.wines = []

    def add_wine(self, wine):
        self.wines.append(wine)

    def serve_wines(self):
        for wine in self.wines:
            wine.serve()


winery = Winery()
winery.add_wine(RedWine("Cabernet Sauvignon", "Каберне Совиньон", 2015))
winery.add_wine(WhiteWine("Chardonnay", "Шардоне", 2018))
winery.add_wine(RoseWine("Grenache", "Гренаш", 2020))
winery.serve_wines()

# Красное вино 'Cabernet Sauvignon', сделанное из винограда сорта Каберне Совиньон
# в 2015 году, рекомендуем подавать комнатной температуры.
# Белое вино 'Chardonnay', сделанное из винограда сорта Шардоне в 2018 году,
# рекомендуем подавать хорошо охлажденным.
# Розовое вино 'Grenache', сделанное из винограда сорта Гренаш в 2020 году,
# рекомендуем подавать слегка охлажденным.


# Задание 8
# Для ПО аэропорта нужно разработать модуль, отслеживающий
# пассажирские и грузовые самолеты, которые отличаются моделью,
# производителем, вместимостью и грузоподъемностью.
#
# Создайте базовый класс Aircraft (воздушное судно) с атрибутами model,
# manufacturer и capacity.
# Затем создайте два подкласса PassengerAircraft и CargoAircraft,
# которые наследуют атрибуты и методы от Aircraft и реализуют свои
# собственные версии метода fly().
# В дополнение создайте класс Airport, который содержит список самолетов и
# имеет метод takeoff(), вызывающий метод fly() для каждого самолета.
from abc import ABC, abstractmethod

class Aircraft(ABC):
    def __init__(self, *args):
        self.model = args[0]
        self.manufacturer = args[1]
        self.capacity = args[2]

    @abstractmethod
    def fly(self):
        pass

class PassengerAircraft(Aircraft):
    def fly(self):
        print(f"Пассажирский самолет '{self.model}' вместимостью {self.capacity} "
              f"человек, произведенный компанией {self.manufacturer}, поднимается в"
              f" воздух с пассажирами на борту.")


class CargoAircraft(Aircraft):
    def fly(self):
        print(f"Грузовой самолет '{self.model}' с грузоподъемностью {self.capacity} т,"
              f"произведенный компанией {self.manufacturer}, поднимается в воздух с "
              f"грузом на борту.")


class Airport():
    def __new__(cls, *args, **kwargs):
        return super().__new__(cls)

    def __init__(self):
        self.planes = []

    def add_aircraft(self, plane):
        self.planes.append(plane.fly())

    def takeoff(self):
        for i in self.planes:
            i


airport = Airport()
airport.add_aircraft(PassengerAircraft("Boeing 747", "Боинг", 416))
airport.add_aircraft(CargoAircraft("Airbus A330", "Эйрбас", 70))
airport.add_aircraft(PassengerAircraft("Boeing 777", "Боинг", 396))
airport.takeoff()

# Пассажирский самолет 'Boeing 747' вместимостью 416 человек, произведенный
# компанией Боинг, поднимается в воздух с пассажирами на борту.
# Грузовой самолет 'Airbus A330' с грузоподъемностью 70 т, произведенный
# компанией Эйрбас, поднимается в воздух с грузом на борту.
# Пассажирский самолет 'Boeing 777' вместимостью 396 человек, произведенный компанией Боинг,
# поднимается в воздух с пассажирами на борту.


# Задание 9
# Необходимо реализовать модуль, отвечающий за обработку данных о
# тестировании конфигурации настольных компьютеров и ноутбуков,
# каждый из которых отличается моделью, процессором, памятью и
# производительностью.
#
# Создайте базовый класс Computer с атрибутами model, processor и memory.
# Затем создайте два подкласса Desktop и Laptop, которые наследуют
# атрибуты и методы Computer и реализуют свои собственные версии метода run().
#
# В дополнение, создайте класс ComputerStore, который содержит список
# компьютеров и имеет метод run_tests(), вызывающий метод run() для каждого
# компьютера.
#
# Используйте декораторы для вывода результатов.
from abc import ABC, abstractmethod


def performance_test(func):
    def wrapper(*args, **kwargs):
        print('Начинаем тест производительности...')
        result = func(*args, **kwargs)
        print('Тест производительности завершен.')
        return result
    return wrapper


class Computer(ABC):
    def __init__(self, *args):
        self.model = args[0]
        self.processor = args[1]
        self.memory = args[2]

    def run(self):
        pass


class Desktop(Computer):
    @performance_test
    def run(self):
        print(f"Запускаем настольный компьютер '{self.model}' с процессором"
              f" {self.processor} и {self.memory} RAM. "
              f"Тест производительности завершен.")


# @performance_run
class Laptop(Computer):
    @performance_test
    def run(self):
        print(f"Запускаем настольный компьютер '{self.model}' с процессором"
              f" {self.processor} и {self.memory} RAM. "
              f"Тест производительности завершен.")


# @performance_run
class ComputerStore:
    def __init__(self):
        self.store = []

    def add_computer(self, comp):
        self.store.append(comp.run())

    def run_tests(self):
        for i in self.store:
            i

store = ComputerStore()
store.add_computer(Desktop("HP Legion", "Intel Core i9-10900K", "64 Гб"))
store.add_computer(Laptop("Dell Xtra", "Intel Core i5 13600K", "32 Гб"))
store.add_computer(Desktop("Lenovo SuperPad", "AMD Ryzen 7 2700X", "16 Гб"))
store.run_tests()

# Начинаем тест производительности...
# Запускаем настольный компьютер 'HP Legion' с процессором Intel Core i9-10900K и 64 Гб RAM.
# Тест производительности завершен.
# Начинаем тест производительности...
# Запускаем ноутбук 'Dell Xtra' с процессором Intel Core i5 13600K и 32 Гб RAM.
# Тест производительности завершен.
# Начинаем тест производительности...
# Запускаем настольный компьютер 'Lenovo SuperPad' с процессором AMD Ryzen 7 2700X и 16 Гб RAM.
# Тест производительности завершен.


# Задание 10
# Определите базовый класс Cryptocurrency, имеющий атрибуты:
#
# name – название;
# symbol – символ-тикер;
# minable – возможность добычи майнингом;
# rate_to_usd – текущий курс к доллару;
# anonymous – наличие анонимных транзакций.
# Затем создайте три подкласса Nano, Iota и Stellar, которые наследуют
# атрибуты и методы родительского класса Cryptocurrency, и обладают
# дополнительными свойствами, влияющими на размер вознаграждения за майнинг:
#
# атрибут block_lattice у Nano;
# tangle у Iota.
# Кроме того, нужно реализовать:
#
# Декоратор minable_required, который проверяет, можно ли майнить
# криптовалюту перед вызовом метода mining_reward(), и выводит сообщение,
# если ее майнить нельзя.

# Функцию print_info, которая принимает на вход экземпляр криптовалюты и
# выводит информацию о монете, включая название, символ, возможность добычи,
# курс к доллару США, анонимность и наличие блок-решетки.
class Cryptocurrency:
    def __init__(self, name, symbol, minable=True, rate_to_usd=1, anonymous=False):
        self.name = name
        self.symbol = symbol
        self.minable = minable
        self.rate_to_usd = rate_to_usd
        self.anonymous = anonymous

    def __str__(self): # WHAT FOR?
        return f'{self.name} ({self.symbol})'

    def mining_reward(self):
        return None


def minable_required(func):
    def wrapper(crypto):
        if not crypto.minable:
            print('Эту криптовалюту не майнят')
            return None
        return func(crypto)
    return wrapper


class Nano(Cryptocurrency):
    def __init__(self, block_lattice=False, rate_to_usd=5, anonymous=True):
        super().__init__('Nano', 'NANO', True, rate_to_usd, anonymous)
        self.block_lattice = block_lattice

    @minable_required
    def mining_reward(self):
        return 0.02 if self.block_lattice else 0.01


class Iota(Cryptocurrency):
    def __init__(self, tangle=False, rate_to_usd=0.1, anonymous=True):
        super().__init__('Iota', 'IOTA', True, rate_to_usd, anonymous)
        self.tangle = tangle

    @minable_required
    def mining_reward(self):
        return 0.02 if self.tangle else 0.01


class Stellar(Cryptocurrency):
    def __init__(self, distributed=False, rate_to_usd=0.1, anonymous=True):
        super().__init__("Stellar", "XLM", False, rate_to_usd, anonymous)
        self.distributed = distributed

    @minable_required
    def mining_reward(self):
        print("Stellar is not minable")
        return None


def print_info(crypto):
    minable_str = 'добывают майнингом' if crypto.minable else 'не майнится'
    anonymity_str = 'анонимные транзакции' if crypto.anonymous else \
        'только публичные транзакции'
    block_lattice_str = 'блок-решетка' if hasattr(crypto, 'block_lattice') \
                                          and crypto.block_lattice else ''

    if block_lattice_str:
        print(f"{crypto}: {minable_str}, "
              f"курс к USD: {crypto.rate_to_usd}, {anonymity_str}, "
              f"{block_lattice_str}")
    else:
        print(f"{crypto}: {minable_str}, "
              f"курс к USD: {crypto.rate_to_usd}, {anonymity_str}")


cryptocurrencies = [Nano(block_lattice=True, rate_to_usd=6, anonymous=False),
                    Iota(tangle=True, rate_to_usd=0.4, anonymous=False),
                    Stellar(distributed=False, rate_to_usd=0.15, anonymous=True)]

for crypto in cryptocurrencies:
    print_info(crypto)
    if crypto.minable:
        print(f"Награда за майнинг: {crypto.mining_reward()} {crypto.symbol}\n")

# Nano (NANO): добывают майнингом, курс к USD: 6, только публичные транзакции, блок-решетка
# Награда за майнинг: 0.02 NANO
#
# Iota (IOTA): добывают майнингом, курс к USD: 0.4, только публичные транзакции
# Награда за майнинг: 0.001 IOTA
#
# Stellar (XLM): не майнится, курс к USD: 0.15, анонимные транзакции
---------------------------------------------
# Практика ФАЙЛЫ

# Задание 1
# Имеется файл books.txt, содержащий следующую информацию:

# 1. "Террор", Дэн Симмонс
# 2. "Она же Грейс", Маргарет Этвуд
# 3. "Облачный атлас", Дэвид Митчелл
# 4. "Искупление", Иэн Макьюэн
# 5. "Госпожа Бовари", Гюстав Флобер
# 6. "Война и мир", Лев Толстой
# 7. "Преступление и наказание", Федор Достоевский
# 8. "Мизери", Стивен Кинг
# 9. "Джейн Эйр", Шарлотта Бронте

# Напишите программу, которая выводит первые 3 строки файла.

lines = ['1. "Террор", Дэн Симмонс\n',
'2. "Она же Грейс", Маргарет Этвуд\n',
'3. "Облачный атлас", Дэвид Митчелл\n',
'4. "Искупление", Иэн Макьюэн\n',
'5. "Госпожа Бовари", Гюстав Флобер\n',
'6. "Война и мир", Лев Толстой\n',
'7. "Преступление и наказание", Федор Достоевский\n',
'8. "Мизери", Стивен Кинг\n',
'9. "Джейн Эйр", Шарлотта Бронте',]

name = 'books.txt'

with open(name, 'w', encoding='utf8') as file:
    file.writelines(lines)

with open(name, encoding='utf8') as file:
    for _ in range(3):
        print(file.readline().strip())


# Задание 2
# Напишите программу, которая получает от пользователя имя файла и возвращает
# следующие данные о его содержимом:
#
# количество строк;
# количество слов;
# число символов без пробелов и точек.
#
# 1. Последнее королевство 2015
# 2. Рим 2005
# 3. Версаль 2015
# 4. Тюдоры 2007
# 5. Террор 2018
# 6. Человек в высоком замке 2015
# 7. Белая королева 2013
# 8. Братья по оружию 2001
# 9. Медичи 2016
# 10. Спартак 2010
#
# Вывод:
#
# Количество строк в файле series.txt: 10
# Количество слов: 17
# Число символов: 153

# name = input('Введите имя файла: ')

# filename = input()
filename = 'books.txt'
lines, words, symbols = 0, 0, 0
with open(filename, 'r', encoding='utf-8') as file:
    for i in file:
        lines += 1
        words += len([w for w in i.strip().split() if w.isalpha()])
        symbols += len([s for s in i if s.isalnum()])
        print([s for s in i if s.isalnum()])

print(f'Количество строк в файле {filename}: {lines}\n'
      f'Количество слов: {words}\n'
      f'Число символов: {symbols}\n'
)


# Задание 3
# Напишите программу, которая находит самое длинное слово в списке книг
# из первого задания.

# 1. "Террор", Дэн Симмонс
# 2. "Она же Грейс", Маргарет Этвуд
# 3. "Облачный атлас", Дэвид Митчелл
# 4. "Искупление", Иэн Макьюэн
# 5. "Госпожа Бовари", Гюстав Флобер
# 6. "Война и мир", Лев Толстой
# 7. "Преступление и наказание", Федор Достоевский
# 8. "Мизери", Стивен Кинг
# 9. "Джейн Эйр", Шарлотта Бронте

with open('books.txt', 'r', encoding='utf-8') as file:
    words = file.read().replace('"', '').split()
    print(words)
    result = [w for w in words if len(w) == len(max(words, key=len))]

print(*result)


# Задание 4
# Имеется файл books.txt со следующим содержимым:
#
# Апельсин маракуйя папайя айва Яблоко
# апельсин яблоко ананас банан персик Слива
# Банан груша слива виноград авокадо Цитрон
# Слива Груша яблоко мандарин цитрон
# лимон Лайм апельсин ананас персик айва
# Хурма киви хурма манго авокадо лайм
# Нектарин Инжир гранат Папайя Гранат

# Названия этих фруктов встречаются в тексте:
# "апельсин" - 3 раз(а)
# "маракуйя" - 1 раз(а)
# "папайя" - 2 раз(а)
# "айва" - 2 раз(а)
# "яблоко" - 3 раз(а)
# "ананас" - 2 раз(а)
# "банан" - 2 раз(а)
# "персик" - 2 раз(а)
# "слива" - 3 раз(а)
# "груша" - 2 раз(а)
# "виноград" - 1 раз(а)
# "авокадо" - 2 раз(а)
# "цитрон" - 2 раз(а)
# "мандарин" - 1 раз(а)
# "лимон" - 1 раз(а)
# "лайм" - 2 раз(а)
# "хурма" - 2 раз(а)
# "киви" - 1 раз(а)
# "манго" - 1 раз(а)
# "нектарин" - 1 раз(а)
# "инжир" - 1 раз(а)
# "гранат" - 2 раз(а)

with open('books.txt', 'r', encoding='utf8') as f:
    fruits = {}
    for w in f.read().lower().split():

        # if w in fruits:
        #     fruits[w] += 1
        # else:
        #     fruits[w] = 1

        fruits[w] = fruits.get(w, 0) + 1

print('Названия этих фруктов встречаются в тексте:')
for key, value in fruits.items():
    print(f'"{key}" - {value} раз(а)')


# Задание 5
# Имеются два файла, first.txt и second.txt. В первом файле перечислены
# имена, во втором – должности:
#
# Содержимое файла first.txt
#
# Сергей Ковалев
# Ирина Егорова
# Никита Степанов
# Марина Арефьева
# Кирилл Евстегнеев
# Елена Моисеева
#
# Файл second.txt
#
# мидл разработчик
# девопс
# тимлид
# сеньор разработчик
# продакт-менеджер
# дизайнер
#
# Напишите программу, которая открывает оба файла и выводит сведения
# о сотрудниках в следующем формате:
#
# Сотрудник Сергей Ковалев, должность - мидл разработчик
# Сотрудник Ирина Егорова, должность - девопс
# Сотрудник Никита Степанов, должность - тимлид
# Сотрудник Марина Арефьева, должность - сеньор разработчик
# Сотрудник Кирилл Евстегнеев, должность - продакт-менеджер
# Сотрудник Елена Моисеева, должность – дизайнер

with open('books.txt', 'r', encoding='utf8') as file:
    names = [line.strip() for line in file.readlines()]

with open('test.txt', 'r', encoding='utf8') as file:
    positions = [line.strip() for line in file.readlines()]

for name, position in zip(names, positions):
    print(f'Сотрудник {name}, должность - {position}')

# ИЛИ:

with open('books.txt', 'r', encoding='utf-8') as file1, \
open('test.txt', 'r', encoding='utf-8') as file2:
    for line_x, line_y in zip(file1, file2):
        print(f'Сотрудник {line_x.strip()}, должность - {line_y.strip()}')


# Задание 6
# Напишите программу, которая:
#
# генерирует коды букв русского алфавита от а до я;
# вставляет в полученный список код ё;
# записывает полный алфавит (строчный и прописной варианты каждой буквы)
# в столбик в файл alphabet.txt.
# Содержимое файла после выполнения программы:
# Аа
# Бб
# Вв
# ...
rus_alph = [chr(index) for index in range(ord("а"), ord("я") + 1)]
rus_alph.insert(6, chr(1105))
rus_alph_cap = [i.upper() for i in rus_alph]

with open('books.txt', 'w', encoding='utf8') as file:
    for s, b in zip(rus_alph, rus_alph_cap):
        file.write(f'{b}{s}\n')

# ИЛИ:

alpha = [i for i in range(ord('а'), ord('я') + 1)]
alpha.insert(6, 1105)
with open('alphabet.txt', 'w', encoding='utf-8') as file:
    for i in alpha:
        file.write(chr(i).upper() + chr(i) + '\n')


# Задание 7
# Сведения о доходах и расходах компании хранятся в двух файлах,
# income.txt и outcome.txt. Напишите программу для подсчета прибыли компании.
#
# Пример файла income.txt:
#
# RUB100000
# RUB200000
# RUB200000
# RUB500000
# RUB600000
# RUB100000
# RUB700000
#
# Пример файла outcome.txt:
#
# -RUB1000
# -RUB2000
# -RUB50000
# -RUB200000
# -RUB10000
# -RUB5000
# -RUB6000
# -RUB10000
# -RUB19000
# -RUB7000
#
# Прибыль за прошлый месяц: 2090000 RUB

with open('books.txt', 'r', encoding='utf8') as file1, \
        open('test.txt', 'r', encoding='utf8') as file2:
    income = sum([int(i.strip('RUB')) for i in file1.read().split()])
    outcome = sum([int(i.strip('-RUB')) for i in file2.read().split()])

print(f'Прибыль за прошлый месяц: {income - outcome} RUB')

# ИЛИ:

income, outcome = 0, 0
with open('books.txt', 'r', encoding='utf-8') as file1, \
open('test.txt', 'r', encoding='utf-8') as file2:
    for line in file1:
        num = line.strip()[3:]
        income += int(num)

    for line in file2:
        num = line.strip()[4:]
        outcome += int(num)
print(f'Прибыль за прошлый месяц: {income - outcome} RUB')


# Задание 8
# Напишите программу, которая считывает сведения об успеваемости по
# основным предметам из файла grades.txt, и определяет, кто из студентов
# имеет средний балл >= 4.5.
#
# Пример файла grades.txt:
#
# Арефьева И. 5 5 4 4
# Богданов С. 5 5 3 4
# Гаврилов Е. 4 4 3 3
# Егорова А.  3 3 3 4
# Семенова Е. 4 3 3 4
# Хворостов И. 5 4 5 5
#
# Арефьева И., средний балл: 4.50
# Хворостов И., средний балл: 4.75

with open('books.txt', 'r', encoding='utf8') as file:
    for line in file:
        lst = line.split()
        av = sum([int(i) for i in lst if i.isdigit()]) / 4
        if av >= 4.5:
            print(f'{lst[0]} {lst[1]}, средний балл: {av:.2f}')

# ИЛИ:

result = {}
with open('grades.txt', 'r', encoding='utf-8') as file1:
    for line in file1:
        l = line.strip().split()
        grades = [int(i) for i in l[-4:]]
        aver_grade = sum(grades) / len(grades)
        if aver_grade >= 4.5:
            result[l[0] + ' ' + l[1]] = aver_grade
for student, aver_grade in result.items():
    print(f'{student}, средний балл: {aver_grade:.2f}')


# Задание 9
# Напишите программу, которая получает от пользователя название файла
# с информацией на русском языке, и выполняет транслитерацию текста
# в соответствии с приведенным ниже словарем.
#
# Результат нужно записать в файл result.txt.

translit = {'а': 'a', 'к': 'k', 'х': 'h', 'б': 'b', 'л': 'l', 'ц': 'c', 'в': 'v', 'м': 'm', 'ч': 'ch', 'г': 'g', 'н': 'n',
     'ш': 'sh', 'д': 'd', 'о': 'o', 'щ': 'shh', 'е': 'e', 'п': 'p', 'ъ': '*', 'ё': 'jo', 'р': 'r', 'ы': 'y', 'ж': 'zh',
     'с': 's', 'ь': "'", 'з': 'z', 'т': 't', 'э': 'je', 'и': 'i', 'у': 'u', 'ю': 'ju', 'й': 'j', 'ф': 'f', 'я': 'ya',
     'А': 'A', 'К': 'K', 'Х': 'H', 'Б': 'B', 'Л': 'L', 'Ц': 'C', 'В': 'V', 'М': 'M', 'Ч': 'Ch', 'Г': 'G', 'Н': 'N',
     'Ш': 'Sh', 'Д': 'D', 'О': 'O', 'Щ': 'Shh', 'Е': 'E', 'П': 'P', 'Ъ': '*', 'Ё': 'Jo', 'Р': 'R', 'Ы': 'Y', 'Ж': 'Zh',
     'С': 'S', 'Ь': "'", 'З': 'Z', 'Т': 'T', 'Э': 'Je', 'И': 'I', 'У': 'U', 'Ю': 'Ju', 'Й': 'J', 'Ф': 'F', 'Я': 'Ya'}

text = 'Python — это язык программирования, который широко используется ' \
       'в интернет-приложениях, разработке программного обеспечения, ' \
       'науке о данных и машинном обучении (ML). Разработчики используют Python, ' \
       'потому что он эффективен, прост в изучении и работает на разных платформах.'

filename = input()
with open(filename, 'r', encoding='utf-8') as source, \
        open('result.txt', 'w', encoding='utf-8') as tr_result:
    for l in source.read():
        trans = translit.get(l.lower(), l)
        tr_result.write(trans if l.islower() else trans.capitalize())


# Задание 10
# Имеется лог-файл crm_log.txt с информацией о времени входа пользователей
# в CRM-систему и о времени выхода.
# Напишите программу, которая определяет пользователей, работавших в системе
# более 4 часов, и записывает их имена и фамилии в файл best_employees.txt.
#
# Пример лога crm_log.txt:
#
# Егор Тимофеев, 09:10, 16:50
# Марина Абрамова, 12:00, 15:59
# Никита Круглов, 09:10, 12:45
# Анна Семенова, 08:10, 12:30
# Юлия Сафонова, 10:10, 10:50
# Михаил Колесников, 11:10, 12:10
#
# Ожидаемый результат в файле best_employees.txt:
#
# Егор Тимофеев
# Анна Семенова

with open('books.txt', 'r', encoding='utf8') as file1, \
        open('test.txt', 'w', encoding='utf8') as file2:
    for line in file1:
        start, end = [int(h) * 60 + int(m) for t in line.split(', ')[1:]
                      for h, m in [t.split(':')]]
        if end - start > 240:
            file2.write(line.split(', ')[0] + '\n')

---------------------------------------------

---------------------------------------------

---------------------------------------------

---------------------------------------------

---------------------------------------------

---------------------------------------------

---------------------------------------------

---------------------------------------------

---------------------------------------------

---------------------------------------------

---------------------------------------------

