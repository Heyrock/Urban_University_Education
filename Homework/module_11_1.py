# Цель: понять разницу между линейным и многопроцессным подходом,
# выполнив операции обоими способами.
#
# Задача "Многопроцессное считывание":
# Необходимо считать информацию из нескольких файлов одновременно,
# используя многопроцессный подход.
#
# Подготовка:
# Скачайте архив с файлами для считывания данных и распакуйте его в проект для
# дальнейшего использования.
#
# Выполнение:
# Создайте функцию read_info(name), где name - название файла. Функция должна:
#
# 1. Создавать локальный список all_data.
# 2. Открывать файл name для чтения.
# 3. Считывать информацию построчно (readline), пока считанная строка не окажется
# пустой.
# 4. Во время считывания добавлять каждую строку в список all_data.
#
# Этих операций достаточно, чтобы рассмотреть преимущество многопроцессного
# выполнения программы над линейным.
#
# 1. Создайте список названий файлов в соответствии с названиями файлов архива.
# 2. Вызовите функцию read_info для каждого файла по очереди (линейно) и измерьте
# время выполнения и выведите его в консоль.
# 3. Вызовите функцию read_info для каждого файла, используя многопроцессный
# подход: контекстный менеджер with и объект Pool. Для вызова функции используйте
# метод map, передав в него функцию read_info и список названий файлов.
# Измерьте время выполнения и выведите его в консоль.
#
# Для избежания некорректного вывода запускайте линейный вызов и многопроцессный
# по отдельности, предварительно закомментировав другой.
#
#
# Пример результата выполнения программы:
# Выполняемый код:
# def read_info(name):
#
#
# # Вывод на консоль, 2 запуска (результаты могут отличаться):
# # 0:00:03.046163 (линейный)
# # 0:00:01.092300 (многопроцессный)
#
# Примечания:
#
# 1. Используйте конструкцию if __name__ == '__main__' при многопроссном подходе.
# 2. Выводить или возвращать список all_data в функции не нужно.
# Можете сделать это, но кол-во информации в файлах достигает - 10^9 строк.
# 3. Дополнительно о классе Pool можете прочитать здесь.

import datetime
from multiprocessing import Pool


def read_info(name):
    all_data = []
    with open(name, 'r', encoding='utf8') as f:
        empty = False
        while not empty:
            line = f.readline()
            all_data.append(line)
            if not line:
                empty = True


# Пример результата выполнения программы:
filenames = [f'module_11_1_file_{number}.txt' for number in range(1, 5)]

# Линейный вызов
start_lin = datetime.datetime.now()
for file in filenames:
    read_info(file)
print(datetime.datetime.now() - start_lin, '(линейный)')
# 0:00:09.871931 (линейный)


# Многопроцессный вызов
if __name__ == '__main__':
    start_mul = datetime.datetime.now()
    with Pool(len(filenames)) as p:
        p.map(read_info, filenames)
    print(datetime.datetime.now() - start_mul, '(многопроцессный)')
# 0:00:03.668743 (многопроцессный)
